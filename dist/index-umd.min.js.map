{"version":3,"file":"index-umd.min.js","sources":["../node_modules/kld-affine/lib/Point2D.js","../node_modules/kld-affine/lib/Vector2D.js","../node_modules/kld-affine/lib/Matrix2D.js","../node_modules/kld-polynomial/lib/Polynomial.js","../lib/IntersectionArgs.js","../lib/Intersection.js","../lib/Shapes.js","../lib/AffineShapes.js","../lib/IntersectionQuery.js"],"sourcesContent":["/**\n *  Point2D.js\n *  @module Point2D\n *  @copyright 2001-2019 Kevin Lindsey\n */\n\n/**\n *  Point2D\n *\n *  @memberof module:kld-affine\n */\nclass Point2D {\n    /**\n     *  Point2D\n     *\n     *  @param {number} x\n     *  @param {number} y\n     *  @returns {module:kld-affine.Point2D}\n     */\n    constructor(x, y) {\n        this.x = x !== undefined ? x : 0.0;\n        this.y = y !== undefined ? y : 0.0;\n    }\n\n    /**\n     *  clone\n     *\n     *  @returns {module:kld-affine.Point2D}\n     */\n    clone() {\n        return new this.constructor(this.x, this.y);\n    }\n\n    /**\n     *  add\n     *\n     *  @param {Point2D|Vector2D} that\n     *  @returns {module:kld-affine.Point2D}\n     */\n    add(that) {\n        return new this.constructor(this.x + that.x, this.y + that.y);\n    }\n\n    /**\n     *  subtract\n     *\n     *  @param { Vector2D | Point2D } that\n     *  @returns {module:kld-affine.Point2D}\n     */\n    subtract(that) {\n        return new this.constructor(this.x - that.x, this.y - that.y);\n    }\n\n    /**\n     *  multiply\n     *\n     *  @param {number} scalar\n     *  @returns {module:kld-affine.Point2D}\n     */\n    multiply(scalar) {\n        return new this.constructor(this.x * scalar, this.y * scalar);\n    }\n\n    /**\n     *  divide\n     *\n     *  @param {number} scalar\n     *  @returns {module:kld-affine.Point2D}\n     */\n    divide(scalar) {\n        return new this.constructor(this.x / scalar, this.y / scalar);\n    }\n\n    /**\n     *  equals\n     *\n     *  @param {module:kld-affine.Point2D} that\n     *  @returns {boolean}\n     */\n    equals(that) {\n        return (this.x === that.x && this.y === that.y);\n    }\n\n    /**\n     *  precisionEquals\n     *\n     *  @param {module:kld-affine.Point2D} that\n     *  @param {number} precision\n     *  @returns {boolean}\n     */\n    precisionEquals(that, precision) {\n        return (\n            Math.abs(this.x - that.x) < precision &&\n            Math.abs(this.y - that.y) < precision\n        );\n    }\n\n    // utility methods\n\n    /**\n     *  lerp\n     *\n     *  @param {module:kld-affine.Point2D} that\n     *  @param {number} t\n     *  @returns {module:kld-affine.Point2D}\n     */\n    lerp(that, t) {\n        const omt = 1.0 - t;\n\n        return new this.constructor(\n            this.x * omt + that.x * t,\n            this.y * omt + that.y * t\n        );\n    }\n\n    /**\n     *  distanceFrom\n     *\n     *  @param {module:kld-affine.Point2D} that\n     *  @returns {number}\n     */\n    distanceFrom(that) {\n        const dx = this.x - that.x;\n        const dy = this.y - that.y;\n\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    /**\n     *  min\n     *\n     *  @param {module:kld-affine.Point2D} that\n     *  @returns {number}\n     */\n    min(that) {\n        return new this.constructor(\n            Math.min(this.x, that.x),\n            Math.min(this.y, that.y)\n        );\n    }\n\n    /**\n     *  max\n     *\n     *  @param {module:kld-affine.Point2D} that\n     *  @returns {number}\n     */\n    max(that) {\n        return new this.constructor(\n            Math.max(this.x, that.x),\n            Math.max(this.y, that.y)\n        );\n    }\n\n    /**\n     *  transform\n     *\n     *  @param {module:kld-affine.Matrix2D} matrix\n     *  @returns {module:kld-affine.Point2D}\n     */\n    transform(matrix) {\n        return new this.constructor(\n            matrix.a * this.x + matrix.c * this.y + matrix.e,\n            matrix.b * this.x + matrix.d * this.y + matrix.f\n        );\n    }\n\n    /**\n     *  toString\n     *\n     *  @returns {string}\n     */\n    toString() {\n        return \"point(\" + this.x + \",\" + this.y + \")\";\n    }\n}\n\nexport default Point2D;\n","/**\n *  Vector2D.js\n *  @module Vector2D\n *  @copyright 2001-2019 Kevin Lindsey\n */\n\n/**\n *  Vector2D\n *\n *  @memberof module:kld-affine\n */\nclass Vector2D {\n    /**\n     *  Vector2D\n     *\n     *  @param {number} x\n     *  @param {number} y\n     *  @returns {module:kld-affine.Vector2D}\n     */\n    constructor(x, y) {\n        this.x = x !== undefined ? x : 0.0;\n        this.y = y !== undefined ? y : 0.0;\n    }\n\n    /**\n     *  fromPoints\n     *\n     *  @param {module:kld-affine.Point2D} p1\n     *  @param {module:kld-affine.Point2D} p2\n     *  @returns {module:kld-affine.Vector2D}\n     */\n    static fromPoints(p1, p2) {\n        return new Vector2D(\n            p2.x - p1.x,\n            p2.y - p1.y\n        );\n    }\n\n    /**\n     *  length\n     *\n     *  @returns {number}\n     */\n    length() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    }\n\n    /**\n     *  magnitude\n     *\n     *  @returns {number}\n     */\n    magnitude() {\n        return this.x * this.x + this.y * this.y;\n    }\n\n    /**\n     *  dot\n     *\n     *  @param {module:kld-affine.Vector2D} that\n     *  @returns {number}\n     */\n    dot(that) {\n        return this.x * that.x + this.y * that.y;\n    }\n\n    /**\n     *  cross\n     *\n     *  @param {module:kld-affine.Vector2D} that\n     *  @returns {number}\n     */\n    cross(that) {\n        return this.x * that.y - this.y * that.x;\n    }\n\n    /**\n     *  determinant\n     *\n     *  @param {module:kld-affine.Vector2D} that\n     *  @returns {number}\n     */\n    determinant(that) {\n        return this.x * that.y - this.y * that.x;\n    }\n\n    /**\n     *  unit\n     *\n     *  @returns {module:kld-affine.Vector2D}\n     */\n    unit() {\n        return this.divide(this.length());\n    }\n\n    /**\n     *  add\n     *\n     *  @param {module:kld-affine.Vector2D} that\n     *  @returns {module:kld-affine.Vector2D}\n     */\n    add(that) {\n        return new this.constructor(this.x + that.x, this.y + that.y);\n    }\n\n    /**\n     *  subtract\n     *\n     *  @param {module:kld-affine.Vector2D} that\n     *  @returns {module:kld-affine.Vector2D}\n     */\n    subtract(that) {\n        return new this.constructor(this.x - that.x, this.y - that.y);\n    }\n\n    /**\n     *  multiply\n     *\n     *  @param {number} scalar\n     *  @returns {module:kld-affine.Vector2D}\n     */\n    multiply(scalar) {\n        return new this.constructor(this.x * scalar, this.y * scalar);\n    }\n\n    /**\n     *  divide\n     *\n     *  @param {number} scalar\n     *  @returns {module:kld-affine.Vector2D}\n     */\n    divide(scalar) {\n        return new this.constructor(this.x / scalar, this.y / scalar);\n    }\n\n    /**\n     *  angleBetween\n     *\n     *  @param {module:kld-affine.Vector2D} that\n     *  @returns {number}\n     */\n    angleBetween(that) {\n        let cos = this.dot(that) / (this.length() * that.length());\n        cos = Math.max(-1, Math.min(cos, 1));\n        const radians = Math.acos(cos);\n\n        return (this.cross(that) < 0.0) ? -radians : radians;\n    }\n\n    /**\n     *  Find a vector is that is perpendicular to this vector\n     *\n     *  @returns {module:kld-affine.Vector2D}\n     */\n    perp() {\n        return new this.constructor(-this.y, this.x);\n    }\n\n    /**\n     *  Find the component of the specified vector that is perpendicular to\n     *  this vector\n     *\n     *  @param {module:kld-affine.Vector2D} that\n     *  @returns {module:kld-affine.Vector2D}\n     */\n    perpendicular(that) {\n        return this.subtract(this.project(that));\n    }\n\n    /**\n     *  project\n     *\n     *  @param {module:kld-affine.Vector2D} that\n     *  @returns {module:kld-affine.Vector2D}\n     */\n    project(that) {\n        const percent = this.dot(that) / that.dot(that);\n\n        return that.multiply(percent);\n    }\n\n    /**\n     *  transform\n     *\n     *  @param {module:kld-affine.Matrix2D} matrix\n     *  @returns {module:kld-affine.Vector2D}\n     */\n    transform(matrix) {\n        return new this.constructor(\n            matrix.a * this.x + matrix.c * this.y,\n            matrix.b * this.x + matrix.d * this.y\n        );\n    }\n\n    /**\n     *  equals\n     *\n     *  @param {module:kld-affine.Vector2D} that\n     *  @returns {boolean}\n     */\n    equals(that) {\n        return (\n            this.x === that.x &&\n            this.y === that.y\n        );\n    }\n\n    /**\n     *  precisionEquals\n     *\n     *  @param {module:kld-affine.Vector2D} that\n     *  @param {number} precision\n     *  @returns {boolean}\n     */\n    precisionEquals(that, precision) {\n        return (\n            Math.abs(this.x - that.x) < precision &&\n            Math.abs(this.y - that.y) < precision\n        );\n    }\n\n    /**\n     *  toString\n     *\n     *  @returns {string}\n     */\n    toString() {\n        return \"vector(\" + this.x + \",\" + this.y + \")\";\n    }\n}\n\nexport default Vector2D;\n","/**\n *  Matrix2D.js\n *  @module Matrix2D\n *  @copyright 2001-2019 Kevin Lindsey\n */\n\n/**\n *  Matrix2D\n *\n *  @memberof module:kld-affine\n */\nclass Matrix2D {\n    /**\n     *  Matrix2D\n     *\n     *  [a c e]\n     *  [b d f]\n     *  [0 0 1]\n     *\n     *  @param {number} a\n     *  @param {number} b\n     *  @param {number} c\n     *  @param {number} d\n     *  @param {number} e\n     *  @param {number} f\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    constructor(a, b, c, d, e, f) {\n        this.a = (a !== undefined) ? a : 1;\n        this.b = (b !== undefined) ? b : 0;\n        this.c = (c !== undefined) ? c : 0;\n        this.d = (d !== undefined) ? d : 1;\n        this.e = (e !== undefined) ? e : 0;\n        this.f = (f !== undefined) ? f : 0;\n    }\n\n    /**\n     *  translation\n     *\n     *  @param {number} tx\n     *  @param {number} ty\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    static translation(tx, ty) {\n        return new Matrix2D(1, 0, 0, 1, tx, ty);\n    }\n\n    /**\n     *  scaling\n     *\n     *  @param {number} scale\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    static scaling(scale) {\n        return new Matrix2D(scale, 0, 0, scale, 0, 0);\n    }\n\n    /**\n     *  scalingAt\n     *\n     *  @param {number} scale\n     *  @param {module:kld-affine.Point2D} center\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    static scalingAt(scale, center) {\n        return new Matrix2D(\n            scale,\n            0,\n            0,\n            scale,\n            center.x - center.x * scale,\n            center.y - center.y * scale\n        );\n    }\n\n\n    /**\n     *  nonUniformScaling\n     *\n     *  @param {number} scaleX\n     *  @param {number} scaleY\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    static nonUniformScaling(scaleX, scaleY) {\n        return new Matrix2D(scaleX, 0, 0, scaleY, 0, 0);\n    }\n\n    /**\n     *  nonUniformScalingAt\n     *\n     *  @param {number} scaleX\n     *  @param {number} scaleY\n     *  @param {module:kld-affine.Point2D} center\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    static nonUniformScalingAt(scaleX, scaleY, center) {\n        return new Matrix2D(\n            scaleX,\n            0,\n            0,\n            scaleY,\n            center.x - center.x * scaleX,\n            center.y - center.y * scaleY\n        );\n    }\n\n    /**\n     *  rotation\n     *\n     *  @param {number} radians\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    static rotation(radians) {\n        const c = Math.cos(radians);\n        const s = Math.sin(radians);\n\n        return new Matrix2D(c, s, -s, c, 0, 0);\n    }\n\n    /**\n     *  rotationAt\n     *\n     *  @param {number} radians\n     *  @param {module:kld-affine.Point2D} center\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    static rotationAt(radians, center) {\n        const c = Math.cos(radians);\n        const s = Math.sin(radians);\n\n        return new Matrix2D(\n            c,\n            s,\n            -s,\n            c,\n            center.x - center.x * c + center.y * s,\n            center.y - center.y * c - center.x * s\n        );\n    }\n\n    /**\n     *  rotationFromVector\n     *\n     *  @param {module:kld-affine.Vector2D} vector\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    static rotationFromVector(vector) {\n        const unit = vector.unit();\n        const c = unit.x; // cos\n        const s = unit.y; // sin\n\n        return new Matrix2D(c, s, -s, c, 0, 0);\n    }\n\n    /**\n     *  xFlip\n     *\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    static xFlip() {\n        return new Matrix2D(-1, 0, 0, 1, 0, 0);\n    }\n\n    /**\n     *  yFlip\n     *\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    static yFlip() {\n        return new Matrix2D(1, 0, 0, -1, 0, 0);\n    }\n\n    /**\n     *  xSkew\n     *\n     *  @param {number} radians\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    static xSkew(radians) {\n        const t = Math.tan(radians);\n\n        return new Matrix2D(1, 0, t, 1, 0, 0);\n    }\n\n    /**\n     *  ySkew\n     *\n     *  @param {number} radians\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    static ySkew(radians) {\n        const t = Math.tan(radians);\n\n        return new Matrix2D(1, t, 0, 1, 0, 0);\n    }\n\n    /**\n     *  multiply\n     *\n     *  @param {module:kld-affine.Matrix2D} that\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    multiply(that) {\n        if (this.isIdentity()) {\n            return that;\n        }\n\n        if (that.isIdentity()) {\n            return this;\n        }\n\n        return new this.constructor(\n            this.a * that.a + this.c * that.b,\n            this.b * that.a + this.d * that.b,\n            this.a * that.c + this.c * that.d,\n            this.b * that.c + this.d * that.d,\n            this.a * that.e + this.c * that.f + this.e,\n            this.b * that.e + this.d * that.f + this.f\n        );\n    }\n\n    /**\n     *  inverse\n     *\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    inverse() {\n        if (this.isIdentity()) {\n            return this;\n        }\n\n        const det1 = this.a * this.d - this.b * this.c;\n\n        if (det1 === 0.0) {\n            throw new Error(\"Matrix is not invertible\");\n        }\n\n        const idet = 1.0 / det1;\n        const det2 = this.f * this.c - this.e * this.d;\n        const det3 = this.e * this.b - this.f * this.a;\n\n        return new this.constructor(\n            this.d * idet,\n            -this.b * idet,\n            -this.c * idet,\n            this.a * idet,\n            det2 * idet,\n            det3 * idet\n        );\n    }\n\n    /**\n     *  translate\n     *\n     *  @param {number} tx\n     *  @param {number} ty\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    translate(tx, ty) {\n        return new this.constructor(\n            this.a,\n            this.b,\n            this.c,\n            this.d,\n            this.a * tx + this.c * ty + this.e,\n            this.b * tx + this.d * ty + this.f\n        );\n    }\n\n    /**\n     *  scale\n     *\n     *  @param {number} scale\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    scale(scale) {\n        return new this.constructor(\n            this.a * scale,\n            this.b * scale,\n            this.c * scale,\n            this.d * scale,\n            this.e,\n            this.f\n        );\n    }\n\n    /**\n     *  scaleAt\n     *\n     *  @param {number} scale\n     *  @param {module:kld-affine.Point2D} center\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    scaleAt(scale, center) {\n        const dx = center.x - scale * center.x;\n        const dy = center.y - scale * center.y;\n\n        return new this.constructor(\n            this.a * scale,\n            this.b * scale,\n            this.c * scale,\n            this.d * scale,\n            this.a * dx + this.c * dy + this.e,\n            this.b * dx + this.d * dy + this.f\n        );\n    }\n\n    /**\n     *  scaleNonUniform\n     *\n     *  @param {number} scaleX\n     *  @param {number} scaleY\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    scaleNonUniform(scaleX, scaleY) {\n        return new this.constructor(\n            this.a * scaleX,\n            this.b * scaleX,\n            this.c * scaleY,\n            this.d * scaleY,\n            this.e,\n            this.f\n        );\n    }\n\n    /**\n     *  scaleNonUniformAt\n     *\n     *  @param {number} scaleX\n     *  @param {number} scaleY\n     *  @param {module:kld-affine.Point2D} center\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    scaleNonUniformAt(scaleX, scaleY, center) {\n        const dx = center.x - scaleX * center.x;\n        const dy = center.y - scaleY * center.y;\n\n        return new this.constructor(\n            this.a * scaleX,\n            this.b * scaleX,\n            this.c * scaleY,\n            this.d * scaleY,\n            this.a * dx + this.c * dy + this.e,\n            this.b * dx + this.d * dy + this.f\n        );\n    }\n\n    /**\n     *  rotate\n     *\n     *  @param {number} radians\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    rotate(radians) {\n        const c = Math.cos(radians);\n        const s = Math.sin(radians);\n\n        return new this.constructor(\n            this.a * c + this.c * s,\n            this.b * c + this.d * s,\n            this.a * -s + this.c * c,\n            this.b * -s + this.d * c,\n            this.e,\n            this.f\n        );\n    }\n\n    /**\n     *  rotateAt\n     *\n     *  @param {number} radians\n     *  @param {module:kld-affine.Point2D} center\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    rotateAt(radians, center) {\n        const cos = Math.cos(radians);\n        const sin = Math.sin(radians);\n        const cx = center.x;\n        const cy = center.y;\n\n        const a = this.a * cos + this.c * sin;\n        const b = this.b * cos + this.d * sin;\n        const c = this.c * cos - this.a * sin;\n        const d = this.d * cos - this.b * sin;\n\n        return new this.constructor(\n            a,\n            b,\n            c,\n            d,\n            (this.a - a) * cx + (this.c - c) * cy + this.e,\n            (this.b - b) * cx + (this.d - d) * cy + this.f\n        );\n    }\n\n    /**\n     *  rotateFromVector\n     *\n     *  @param {module:kld-affine.Vector2D} vector\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    rotateFromVector(vector) {\n        const unit = vector.unit();\n        const c = unit.x; // cos\n        const s = unit.y; // sin\n\n        return new this.constructor(\n            this.a * c + this.c * s,\n            this.b * c + this.d * s,\n            this.a * -s + this.c * c,\n            this.b * -s + this.d * c,\n            this.e,\n            this.f\n        );\n    }\n\n    /**\n     *  flipX\n     *\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    flipX() {\n        return new this.constructor(\n            -this.a,\n            -this.b,\n            this.c,\n            this.d,\n            this.e,\n            this.f\n        );\n    }\n\n    /**\n     *  flipY\n     *\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    flipY() {\n        return new this.constructor(\n            this.a,\n            this.b,\n            -this.c,\n            -this.d,\n            this.e,\n            this.f\n        );\n    }\n\n    /**\n     *  skewX\n     *\n     *  @param {number} radians\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    skewX(radians) {\n        const t = Math.tan(radians);\n\n        return new this.constructor(\n            this.a,\n            this.b,\n            this.c + this.a * t,\n            this.d + this.b * t,\n            this.e,\n            this.f\n        );\n    }\n\n    // TODO: skewXAt\n\n    /**\n     *  skewY\n     *\n     *  @param {number} radians\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    skewY(radians) {\n        const t = Math.tan(radians);\n\n        return new this.constructor(\n            this.a + this.c * t,\n            this.b + this.d * t,\n            this.c,\n            this.d,\n            this.e,\n            this.f\n        );\n    }\n\n    // TODO: skewYAt\n\n    /**\n     *  isIdentity\n     *\n     *  @returns {boolean}\n     */\n    isIdentity() {\n        return (\n            this.a === 1.0 &&\n            this.b === 0.0 &&\n            this.c === 0.0 &&\n            this.d === 1.0 &&\n            this.e === 0.0 &&\n            this.f === 0.0\n        );\n    }\n\n    /**\n     *  isInvertible\n     *\n     *  @returns {boolean}\n     */\n    isInvertible() {\n        return this.a * this.d - this.b * this.c !== 0.0;\n    }\n\n    /**\n     *  getScale\n     *\n     *  @returns {{ scaleX: number, scaleY: number }}\n     */\n    getScale() {\n        return {\n            scaleX: Math.sqrt(this.a * this.a + this.c * this.c),\n            scaleY: Math.sqrt(this.b * this.b + this.d * this.d)\n        };\n    }\n\n    /**\n     *  getDecomposition\n     *\n     *  Calculates matrix Singular Value Decomposition\n     *\n     *  The resulting matrices, translation, rotation, scale, and rotation0, return\n     *  this matrix when they are muliplied together in the listed order\n     *\n     *  @see Jim Blinn's article {@link http://dx.doi.org/10.1109/38.486688}\n     *  @see {@link http://math.stackexchange.com/questions/861674/decompose-a-2d-arbitrary-transform-into-only-scaling-and-rotation}\n     *\n     *  @returns {{ translation: module:kld-affine.Matrix2D, rotation: module:kld-affine.Matrix2D, scale: module:kld-affine.Matrix2D, rotation0: module:kld-affine.Matrix2D }}\n     */\n    getDecomposition() {\n        const E = (this.a + this.d) * 0.5;\n        const F = (this.a - this.d) * 0.5;\n        const G = (this.b + this.c) * 0.5;\n        const H = (this.b - this.c) * 0.5;\n\n        const Q = Math.sqrt(E * E + H * H);\n        const R = Math.sqrt(F * F + G * G);\n        const scaleX = Q + R;\n        const scaleY = Q - R;\n\n        const a1 = Math.atan2(G, F);\n        const a2 = Math.atan2(H, E);\n        const theta = (a2 - a1) * 0.5;\n        const phi = (a2 + a1) * 0.5;\n\n        return {\n            translation: this.constructor.translation(this.e, this.f),\n            rotation: this.constructor.rotation(phi),\n            scale: this.constructor.nonUniformScaling(scaleX, scaleY),\n            rotation0: this.constructor.rotation(theta)\n        };\n    }\n\n    /**\n     *  equals\n     *\n     *  @param {module:kld-affine.Matrix2D} that\n     *  @returns {boolean}\n     */\n    equals(that) {\n        return (\n            this.a === that.a &&\n            this.b === that.b &&\n            this.c === that.c &&\n            this.d === that.d &&\n            this.e === that.e &&\n            this.f === that.f\n        );\n    }\n\n    /**\n     *  precisionEquals\n     *\n     *  @param {module:kld-affine.Matrix2D} that\n     *  @param {number} precision\n     *  @returns {boolean}\n     */\n    precisionEquals(that, precision) {\n        return (\n            Math.abs(this.a - that.a) < precision &&\n            Math.abs(this.b - that.b) < precision &&\n            Math.abs(this.c - that.c) < precision &&\n            Math.abs(this.d - that.d) < precision &&\n            Math.abs(this.e - that.e) < precision &&\n            Math.abs(this.f - that.f) < precision\n        );\n    }\n\n    /**\n     *  toString\n     *\n     *  @returns {string}\n     */\n    toString() {\n        return \"matrix(\" + [this.a, this.b, this.c, this.d, this.e, this.f].join(\",\") + \")\";\n    }\n}\n\n/**\n *  Identity matrix\n *\n *  @returns {module:kld-affine.Matrix2D}\n */\nMatrix2D.IDENTITY = new Matrix2D();\nMatrix2D.IDENTITY.isIdentity = () => true;\n\n\nexport default Matrix2D;\n","/* eslint-disable camelcase, unicorn/prefer-type-error */\n/**\n *  Polynomial.js\n *\n *  @module Polynomial\n *  @copyright 2002-2019 Kevin Lindsey<br>\n *  -<br>\n *  Contribution {@link http://github.com/Quazistax/kld-polynomial}<br>\n *  2015 Robert Benko (Quazistax) <quazistax@gmail.com><br>\n *  MIT license\n */\n\n/**\n *  Sign of a number (+1, -1, +0, -0).\n *\n *  @param {number} x\n *  @returns {number}\n */\nfunction sign(x) {\n    // eslint-disable-next-line no-self-compare\n    return typeof x === \"number\" ? x ? x < 0 ? -1 : 1 : x === x ? x : NaN : NaN;\n}\n\n\n/**\n *  Polynomial\n *\n *  @memberof module:kld-polynomial\n */\nclass Polynomial {\n    /**\n     *  Polynomial\n     *\n     *  @param {Array<number>} coefs\n     *  @returns {module:kld-polynomial.Polynomial}\n     */\n    constructor(...coefs) {\n        this.coefs = [];\n\n        for (let i = coefs.length - 1; i >= 0; i--) {\n            this.coefs.push(coefs[i]);\n        }\n\n        this._variable = \"t\";\n        this._s = 0;\n    }\n\n    /**\n     *  interpolate\n     *\n     *  Based on poloint in \"Numerical Recipes in C, 2nd Edition\", pages 109-110\n     *\n     *  @param {Array<number>} xs\n     *  @param {Array<number>} ys\n     *  @param {number} n\n     *  @param {number} offset\n     *  @param {number} x\n     *\n     *  @returns {{y: number, dy: number}}\n     */\n    static interpolate(xs, ys, n, offset, x) {\n        if (xs.constructor !== Array || ys.constructor !== Array) {\n            throw new Error(\"Polynomial.interpolate: xs and ys must be arrays\");\n        }\n        if (isNaN(n) || isNaN(offset) || isNaN(x)) {\n            throw new Error(\"Polynomial.interpolate: n, offset, and x must be numbers\");\n        }\n\n        let i;\n        let y = 0;\n        let dy = 0;\n        const c = new Array(n);\n        const d = new Array(n);\n        let ns = 0;\n\n        let diff = Math.abs(x - xs[offset]);\n\n        for (i = 0; i < n; i++) {\n            const dift = Math.abs(x - xs[offset + i]);\n\n            if (dift < diff) {\n                ns = i;\n                diff = dift;\n            }\n            c[i] = d[i] = ys[offset + i];\n        }\n\n        y = ys[offset + ns];\n        ns--;\n\n        for (let m = 1; m < n; m++) {\n            for (i = 0; i < n - m; i++) {\n                const ho = xs[offset + i] - x;\n                const hp = xs[offset + i + m] - x;\n                const w = c[i + 1] - d[i];\n                let den = ho - hp;\n\n                if (den === 0.0) {\n                    throw new Error(\"Unable to interpolate polynomial. Two numbers in n were identical (to within roundoff)\");\n                }\n\n                den = w / den;\n                d[i] = hp * den;\n                c[i] = ho * den;\n            }\n\n            dy = (2 * (ns + 1) < (n - m)) ? c[ns + 1] : d[ns--];\n            y += dy;\n        }\n\n        return {y, dy};\n    }\n\n    /**\n     *  Newton's (Newton-Raphson) method for finding Real roots on univariate function. <br/>\n     *  When using bounds, algorithm falls back to secant if newton goes out of range.\n     *  Bisection is fallback for secant when determined secant is not efficient enough.\n     *  @see {@link http://en.wikipedia.org/wiki/Newton%27s_method}\n     *  @see {@link http://en.wikipedia.org/wiki/Secant_method}\n     *  @see {@link http://en.wikipedia.org/wiki/Bisection_method}\n     *\n     *  @param {number} x0 - Inital root guess\n     *  @param {Function} f - Function which root we are trying to find\n     *  @param {Function} df - Derivative of function f\n     *  @param {number} max_iterations - Maximum number of algorithm iterations\n     *  @param {number} [min] - Left bound value\n     *  @param {number} [max] - Right bound value\n     *  @returns {number} root\n     */\n    static newton_secant_bisection(x0, f, df, max_iterations, min, max) {\n        let x, prev_dfx = 0, dfx, prev_x_ef_correction = 0, x_correction, x_new;\n        let y, y_atmin, y_atmax;\n\n        x = x0;\n\n        const ACCURACY = 14;\n        const min_correction_factor = Math.pow(10, -ACCURACY);\n        const isBounded = (typeof min === \"number\" && typeof max === \"number\");\n\n        if (isBounded) {\n            if (min > max) {\n                throw new Error(\"newton root finding: min must be greater than max\");\n            }\n\n            y_atmin = f(min);\n            y_atmax = f(max);\n\n            if (sign(y_atmin) === sign(y_atmax)) {\n                throw new Error(\"newton root finding: y values of bounds must be of opposite sign\");\n            }\n        }\n\n        const isEnoughCorrection = function() {\n            // stop if correction is too small or if correction is in simple loop\n            return (Math.abs(x_correction) <= min_correction_factor * Math.abs(x)) ||\n                (prev_x_ef_correction === (x - x_correction) - x);\n        };\n\n\n        for (let i = 0; i < max_iterations; i++) {\n            dfx = df(x);\n\n            if (dfx === 0) {\n                if (prev_dfx === 0) {\n                    // error\n                    throw new Error(\"newton root finding: df(x) is zero\");\n                }\n                else {\n                    // use previous derivation value\n                    dfx = prev_dfx;\n                }\n                // or move x a little?\n                // dfx = df(x != 0 ? x + x * 1e-15 : 1e-15);\n            }\n\n            prev_dfx = dfx;\n            y = f(x);\n            x_correction = y / dfx;\n            x_new = x - x_correction;\n\n            if (isEnoughCorrection()) {\n                break;\n            }\n\n            if (isBounded) {\n                if (sign(y) === sign(y_atmax)) {\n                    max = x;\n                    y_atmax = y;\n                }\n                else if (sign(y) === sign(y_atmin)) {\n                    min = x;\n                    y_atmin = y;\n                }\n                else {\n                    x = x_new;\n                    break;\n                }\n\n                if ((x_new < min) || (x_new > max)) {\n                    if (sign(y_atmin) === sign(y_atmax)) {\n                        break;\n                    }\n\n                    const RATIO_LIMIT = 50;\n                    const AIMED_BISECT_OFFSET = 0.25; // [0, 0.5)\n                    const dy = y_atmax - y_atmin;\n                    const dx = max - min;\n\n                    if (dy === 0) {\n                        x_correction = x - (min + dx * 0.5);\n                    }\n                    else if (Math.abs(dy / Math.min(y_atmin, y_atmax)) > RATIO_LIMIT) {\n                        x_correction = x - (min + dx * (0.5 + (Math.abs(y_atmin) < Math.abs(y_atmax) ? -AIMED_BISECT_OFFSET : AIMED_BISECT_OFFSET)));\n                    }\n                    else {\n                        x_correction = x - (min - y_atmin / dy * dx);\n                    }\n                    x_new = x - x_correction;\n\n                    if (isEnoughCorrection()) {\n                        break;\n                    }\n                }\n            }\n\n            prev_x_ef_correction = x - x_new;\n            x = x_new;\n        }\n\n        return x;\n    }\n\n    /**\n     *  Clones this polynomial and return the clone.\n     *\n     *  @returns {module:kld-polynomial.Polynomial}\n     */\n    clone() {\n        const poly = new Polynomial();\n\n        poly.coefs = this.coefs.slice();\n\n        return poly;\n    }\n\n    /**\n     *  eval\n     *\n     *  @param {number} x\n     */\n    eval(x) {\n        if (isNaN(x)) {\n            throw new Error(`Polynomial.eval: parameter must be a number, got '${x}'`);\n        }\n\n        let result = 0;\n\n        for (let i = this.coefs.length - 1; i >= 0; i--) {\n            result = result * x + this.coefs[i];\n        }\n\n        return result;\n    }\n\n    /**\n     *  add\n     *\n     *  @param {module:kld-polynomial.Polynomial} that\n     *  @returns {module:kld-polynomial.Polynomial}\n     */\n    add(that) {\n        const result = new Polynomial();\n        const d1 = this.getDegree();\n        const d2 = that.getDegree();\n        const dmax = Math.max(d1, d2);\n\n        for (let i = 0; i <= dmax; i++) {\n            const v1 = (i <= d1) ? this.coefs[i] : 0;\n            const v2 = (i <= d2) ? that.coefs[i] : 0;\n\n            result.coefs[i] = v1 + v2;\n        }\n\n        return result;\n    }\n\n    /**\n     *  multiply\n     *\n     *  @param {module:kld-polynomial.Polynomial} that\n     *  @returns {module:kld-polynomial.Polynomial}\n     */\n    multiply(that) {\n        const result = new Polynomial();\n\n        for (let i = 0; i <= this.getDegree() + that.getDegree(); i++) {\n            result.coefs.push(0);\n        }\n\n        for (let i = 0; i <= this.getDegree(); i++) {\n            for (let j = 0; j <= that.getDegree(); j++) {\n                result.coefs[i + j] += this.coefs[i] * that.coefs[j];\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     *  divide_scalar\n     *\n     *  @param {number} scalar\n     */\n    divide_scalar(scalar) {\n        for (let i = 0; i < this.coefs.length; i++) {\n            this.coefs[i] /= scalar;\n        }\n    }\n\n    /**\n     *  simplify\n     *\n     *  @param {number} TOLERANCE\n     */\n    simplify(TOLERANCE) {\n        if (TOLERANCE === undefined) {\n            TOLERANCE = 1e-12;\n        }\n\n        for (let i = this.getDegree(); i >= 0; i--) {\n            if (Math.abs(this.coefs[i]) <= TOLERANCE) {\n                this.coefs.pop();\n            }\n            else {\n                break;\n            }\n        }\n    }\n\n    /**\n     *  bisection\n     *\n     *  @param {number} min\n     *  @param {number} max\n     *\n     *  @returns {number}\n     */\n    bisection(min, max) {\n        let minValue = this.eval(min);\n        let maxValue = this.eval(max);\n        let result;\n\n        if (Math.abs(minValue) <= Polynomial.TOLERANCE) {\n            result = min;\n        }\n        else if (Math.abs(maxValue) <= Polynomial.TOLERANCE) {\n            result = max;\n        }\n        else if (minValue * maxValue <= 0) {\n            const tmp1 = Math.log(max - min);\n            const tmp2 = Math.LN10 * Polynomial.ACCURACY;\n            const iters = Math.ceil((tmp1 + tmp2) / Math.LN2);\n\n            for (let i = 0; i < iters; i++) {\n                result = 0.5 * (min + max);\n                const value = this.eval(result);\n\n                if (Math.abs(value) <= Polynomial.TOLERANCE) {\n                    break;\n                }\n\n                if (value * minValue < 0) {\n                    max = result;\n                    maxValue = value;\n                }\n                else {\n                    min = result;\n                    minValue = value;\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     *  toString\n     *\n     *  @returns {string}\n     */\n    toString() {\n        const coefs = [];\n        const signs = [];\n\n        for (let i = this.coefs.length - 1; i >= 0; i--) {\n            let value = Math.round(this.coefs[i] * 1000) / 1000;\n\n            if (value !== 0) {\n                const signString = (value < 0) ? \" - \" : \" + \";\n\n                value = Math.abs(value);\n\n                if (i > 0) {\n                    if (value === 1) {\n                        value = this._variable;\n                    }\n                    else {\n                        value += this._variable;\n                    }\n                }\n\n                if (i > 1) {\n                    value += \"^\" + i;\n                }\n\n                signs.push(signString);\n                coefs.push(value);\n            }\n        }\n\n        signs[0] = (signs[0] === \" + \") ? \"\" : \"-\";\n\n        let result = \"\";\n\n        for (let i = 0; i < coefs.length; i++) {\n            result += signs[i] + coefs[i];\n        }\n\n        return result;\n    }\n\n    /**\n     *  trapezoid\n     *\n     *  Based on trapzd in \"Numerical Recipes in C, 2nd Edition\", page 137\n     *\n     *  @param {number} min\n     *  @param {number} max\n     *  @param {number} n\n     *  @returns {number}\n     */\n    trapezoid(min, max, n) {\n        if (isNaN(min) || isNaN(max) || isNaN(n)) {\n            throw new Error(\"Polynomial.trapezoid: parameters must be numbers\");\n        }\n\n        const range = max - min;\n\n        if (n === 1) {\n            const minValue = this.eval(min);\n            const maxValue = this.eval(max);\n\n            this._s = 0.5 * range * (minValue + maxValue);\n        }\n        else {\n            const iter = 1 << (n - 2);\n            const delta = range / iter;\n            let x = min + 0.5 * delta;\n            let sum = 0;\n\n            for (let i = 0; i < iter; i++) {\n                sum += this.eval(x);\n                x += delta;\n            }\n\n            this._s = 0.5 * (this._s + range * sum / iter);\n        }\n\n        if (isNaN(this._s)) {\n            throw new Error(\"Polynomial.trapezoid: this._s is NaN\");\n        }\n\n        return this._s;\n    }\n\n    /**\n     *  simpson\n     *\n     *  Based on trapzd in \"Numerical Recipes in C, 2nd Edition\", page 139\n     *\n     *  @param {number} min\n     *  @param {number} max\n     *  @returns {number}\n     */\n    simpson(min, max) {\n        if (isNaN(min) || isNaN(max)) {\n            throw new Error(\"Polynomial.simpson: parameters must be numbers\");\n        }\n\n        const range = max - min;\n        let st = 0.5 * range * (this.eval(min) + this.eval(max));\n        let t = st;\n        let s = 4.0 * st / 3.0;\n        let os = s;\n        let ost = st;\n        const TOLERANCE = 1e-7;\n\n        let iter = 1;\n\n        for (let n = 2; n <= 20; n++) {\n            const delta = range / iter;\n            let x = min + 0.5 * delta;\n            let sum = 0;\n\n            for (let i = 1; i <= iter; i++) {\n                sum += this.eval(x);\n                x += delta;\n            }\n\n            t = 0.5 * (t + range * sum / iter);\n            st = t;\n            s = (4.0 * st - ost) / 3.0;\n\n            if (Math.abs(s - os) < TOLERANCE * Math.abs(os)) {\n                break;\n            }\n\n            os = s;\n            ost = st;\n            iter <<= 1;\n        }\n\n        return s;\n    }\n\n    /**\n     *  romberg\n     *\n     *  @param {number} min\n     *  @param {number} max\n     *  @returns {number}\n     */\n    romberg(min, max) {\n        if (isNaN(min) || isNaN(max)) {\n            throw new Error(\"Polynomial.romberg: parameters must be numbers\");\n        }\n\n        const MAX = 20;\n        const K = 3;\n        const TOLERANCE = 1e-6;\n        const s = new Array(MAX + 1);\n        const h = new Array(MAX + 1);\n        let result = {y: 0, dy: 0};\n\n        h[0] = 1.0;\n\n        for (let j = 1; j <= MAX; j++) {\n            s[j - 1] = this.trapezoid(min, max, j);\n\n            if (j >= K) {\n                result = Polynomial.interpolate(h, s, K, j - K, 0.0);\n                if (Math.abs(result.dy) <= TOLERANCE * result.y) {\n                    break;\n                }\n            }\n\n            s[j] = s[j - 1];\n            h[j] = 0.25 * h[j - 1];\n        }\n\n        return result.y;\n    }\n\n    // getters and setters\n\n    /**\n     *  get degree\n     *\n     *  @returns {number}\n     */\n    getDegree() {\n        return this.coefs.length - 1;\n    }\n\n    /**\n     *  getDerivative\n     *\n     *  @returns {module:kld-polynomial.Polynomial}\n     */\n    getDerivative() {\n        const derivative = new Polynomial();\n\n        for (let i = 1; i < this.coefs.length; i++) {\n            derivative.coefs.push(i * this.coefs[i]);\n        }\n\n        return derivative;\n    }\n\n    /**\n     *  getRoots\n     *\n     *  @returns {Array<number>}\n     */\n    getRoots() {\n        let result;\n\n        this.simplify();\n\n        switch (this.getDegree()) {\n            case 0: result = []; break;\n            case 1: result = this.getLinearRoot(); break;\n            case 2: result = this.getQuadraticRoots(); break;\n            case 3: result = this.getCubicRoots(); break;\n            case 4: result = this.getQuarticRoots(); break;\n            default:\n                result = [];\n        }\n\n        return result;\n    }\n\n    /**\n     *  getRootsInInterval\n     *\n     *  @param {number} min\n     *  @param {number} max\n     *  @returns {Array<number>}\n     */\n    getRootsInInterval(min, max) {\n        const roots = [];\n\n        /**\n         *  @param {number} value\n         */\n        function push(value) {\n            if (typeof value === \"number\") {\n                roots.push(value);\n            }\n        }\n\n        if (this.getDegree() === 0) {\n            throw new Error(\"Polynomial.getRootsInInterval: Unexpected empty polynomial\");\n        }\n        else if (this.getDegree() === 1) {\n            push(this.bisection(min, max));\n        }\n        else {\n            // get roots of derivative\n            const deriv = this.getDerivative();\n            const droots = deriv.getRootsInInterval(min, max);\n\n            if (droots.length > 0) {\n                // find root on [min, droots[0]]\n                push(this.bisection(min, droots[0]));\n\n                // find root on [droots[i],droots[i+1]] for 0 <= i <= count-2\n                for (let i = 0; i <= droots.length - 2; i++) {\n                    push(this.bisection(droots[i], droots[i + 1]));\n                }\n\n                // find root on [droots[count-1],xmax]\n                push(this.bisection(droots[droots.length - 1], max));\n            }\n            else {\n                // polynomial is monotone on [min,max], has at most one root\n                push(this.bisection(min, max));\n            }\n        }\n\n        return roots;\n    }\n\n    /**\n     *  getLinearRoot\n     *\n     *  @returns {number}\n     */\n    getLinearRoot() {\n        const result = [];\n        const a = this.coefs[1];\n\n        if (a !== 0) {\n            result.push(-this.coefs[0] / a);\n        }\n\n        return result;\n    }\n\n    /**\n     *  getQuadraticRoots\n     *\n     *  @returns {Array<number>}\n     */\n    getQuadraticRoots() {\n        const results = [];\n\n        if (this.getDegree() === 2) {\n            const a = this.coefs[2];\n            const b = this.coefs[1] / a;\n            const c = this.coefs[0] / a;\n            const d = b * b - 4 * c;\n\n            if (d > 0) {\n                const e = Math.sqrt(d);\n\n                results.push(0.5 * (-b + e));\n                results.push(0.5 * (-b - e));\n            }\n            else if (d === 0) {\n                // really two roots with same value, but we only return one\n                results.push(0.5 * -b);\n            }\n        }\n\n        return results;\n    }\n\n    /**\n     *  getCubicRoots\n     *\n     *  This code is based on MgcPolynomial.cpp written by David Eberly.  His\n     *  code along with many other excellent examples are avaiable at his site:\n     *  http://www.geometrictools.com\n     *\n     *  @returns {Array<number>}\n     */\n    getCubicRoots() {\n        const results = [];\n\n        if (this.getDegree() === 3) {\n            const c3 = this.coefs[3];\n            const c2 = this.coefs[2] / c3;\n            const c1 = this.coefs[1] / c3;\n            const c0 = this.coefs[0] / c3;\n\n            const a = (3 * c1 - c2 * c2) / 3;\n            const b = (2 * c2 * c2 * c2 - 9 * c1 * c2 + 27 * c0) / 27;\n            const offset = c2 / 3;\n            let discrim = b * b / 4 + a * a * a / 27;\n            const halfB = b / 2;\n\n            const ZEROepsilon = this.zeroErrorEstimate();\n\n            if (Math.abs(discrim) <= ZEROepsilon) {\n                discrim = 0;\n            }\n\n            if (discrim > 0) {\n                const e = Math.sqrt(discrim);\n                let root; // eslint-disable-line no-shadow\n\n                let tmp = -halfB + e;\n\n                if (tmp >= 0) {\n                    root = Math.pow(tmp, 1 / 3);\n                }\n                else {\n                    root = -Math.pow(-tmp, 1 / 3);\n                }\n\n                tmp = -halfB - e;\n\n                if (tmp >= 0) {\n                    root += Math.pow(tmp, 1 / 3);\n                }\n                else {\n                    root -= Math.pow(-tmp, 1 / 3);\n                }\n\n                results.push(root - offset);\n            }\n            else if (discrim < 0) {\n                const distance = Math.sqrt(-a / 3);\n                const angle = Math.atan2(Math.sqrt(-discrim), -halfB) / 3;\n                const cos = Math.cos(angle);\n                const sin = Math.sin(angle);\n                const sqrt3 = Math.sqrt(3);\n\n                results.push(2 * distance * cos - offset);\n                results.push(-distance * (cos + sqrt3 * sin) - offset);\n                results.push(-distance * (cos - sqrt3 * sin) - offset);\n            }\n            else {\n                let tmp;\n\n                if (halfB >= 0) {\n                    tmp = -Math.pow(halfB, 1 / 3);\n                }\n                else {\n                    tmp = Math.pow(-halfB, 1 / 3);\n                }\n\n                results.push(2 * tmp - offset);\n                // really should return next root twice, but we return only one\n                results.push(-tmp - offset);\n            }\n        }\n\n        return results;\n    }\n\n    /**\n     *  Calculates roots of quartic polynomial. <br/>\n     *  First, derivative roots are found, then used to split quartic polynomial\n     *  into segments, each containing one root of quartic polynomial.\n     *  Segments are then passed to newton's method to find roots.\n     *\n     *  @returns {Array<number>} roots\n     */\n    getQuarticRoots() {\n        let results = [];\n        const n = this.getDegree();\n\n        if (n === 4) {\n            const poly = new Polynomial();\n\n            poly.coefs = this.coefs.slice();\n            poly.divide_scalar(poly.coefs[n]);\n\n            const ERRF = 1e-15;\n\n            if (Math.abs(poly.coefs[0]) < 10 * ERRF * Math.abs(poly.coefs[3])) {\n                poly.coefs[0] = 0;\n            }\n\n            const poly_d = poly.getDerivative();\n            const derrt = poly_d.getRoots().sort((a, b) => a - b);\n            const dery = [];\n            const nr = derrt.length - 1;\n            const rb = this.bounds();\n\n            const maxabsX = Math.max(Math.abs(rb.minX), Math.abs(rb.maxX));\n            const ZEROepsilon = this.zeroErrorEstimate(maxabsX);\n\n            for (let i = 0; i <= nr; i++) {\n                dery.push(poly.eval(derrt[i]));\n            }\n\n            for (let i = 0; i <= nr; i++) {\n                if (Math.abs(dery[i]) < ZEROepsilon) {\n                    dery[i] = 0;\n                }\n            }\n\n            let i = 0;\n            const dx = Math.max(0.1 * (rb.maxX - rb.minX) / n, ERRF);\n            const guesses = [];\n            const minmax = [];\n\n            if (nr > -1) {\n                if (dery[0] !== 0) {\n                    if (sign(dery[0]) !== sign(poly.eval(derrt[0] - dx) - dery[0])) {\n                        guesses.push(derrt[0] - dx);\n                        minmax.push([rb.minX, derrt[0]]);\n                    }\n                }\n                else {\n                    results.push(derrt[0], derrt[0]);\n                    i++;\n                }\n\n                for (; i < nr; i++) {\n                    if (dery[i + 1] === 0) {\n                        results.push(derrt[i + 1], derrt[i + 1]);\n                        i++;\n                    }\n                    else if (sign(dery[i]) !== sign(dery[i + 1])) {\n                        guesses.push((derrt[i] + derrt[i + 1]) / 2);\n                        minmax.push([derrt[i], derrt[i + 1]]);\n                    }\n                }\n                if (dery[nr] !== 0 && sign(dery[nr]) !== sign(poly.eval(derrt[nr] + dx) - dery[nr])) {\n                    guesses.push(derrt[nr] + dx);\n                    minmax.push([derrt[nr], rb.maxX]);\n                }\n            }\n\n            /**\n             *  @param {number} x\n             *  @returns {number}\n             */\n            const f = function(x) {\n                return poly.eval(x);\n            };\n\n            /**\n             *  @param {number} x\n             *  @returns {number}\n             */\n            const df = function(x) {\n                return poly_d.eval(x);\n            };\n\n            if (guesses.length > 0) {\n                for (i = 0; i < guesses.length; i++) {\n                    guesses[i] = Polynomial.newton_secant_bisection(guesses[i], f, df, 32, minmax[i][0], minmax[i][1]);\n                }\n            }\n\n            results = results.concat(guesses);\n        }\n\n        return results;\n    }\n\n    /**\n     *  Estimate what is the maximum polynomial evaluation error value under which polynomial evaluation could be in fact 0.\n     *\n     *  @param {number} maxabsX\n     *  @returns {number}\n     */\n    zeroErrorEstimate(maxabsX) {\n        const poly = this;\n        const ERRF = 1e-15;\n\n        if (typeof maxabsX === \"undefined\") {\n            const rb = poly.bounds();\n\n            maxabsX = Math.max(Math.abs(rb.minX), Math.abs(rb.maxX));\n        }\n\n        if (maxabsX < 0.001) {\n            return 2 * Math.abs(poly.eval(ERRF));\n        }\n\n        const n = poly.coefs.length - 1;\n        const an = poly.coefs[n];\n\n        return 10 * ERRF * poly.coefs.reduce((m, v, i) => {\n            const nm = v / an * Math.pow(maxabsX, i);\n            return nm > m ? nm : m;\n        }, 0);\n    }\n\n    /**\n     *  Calculates upper Real roots bounds. <br/>\n     *  Real roots are in interval [negX, posX]. Determined by Fujiwara method.\n     *  @see {@link http://en.wikipedia.org/wiki/Properties_of_polynomial_roots}\n     *\n     *  @returns {{ negX: number, posX: number }}\n     */\n    bounds_UpperReal_Fujiwara() {\n        let a = this.coefs;\n        const n = a.length - 1;\n        const an = a[n];\n\n        if (an !== 1) {\n            a = this.coefs.map(v => v / an);\n        }\n\n        const b = a.map((v, i) => {\n            return (i < n)\n                ? Math.pow(Math.abs((i === 0) ? v / 2 : v), 1 / (n - i))\n                : v;\n        });\n\n        let coefSelectionFunc;\n        const find2Max = function(acc, bi, i) {\n            if (coefSelectionFunc(i)) {\n                if (acc.max < bi) {\n                    acc.nearmax = acc.max;\n                    acc.max = bi;\n                }\n                else if (acc.nearmax < bi) {\n                    acc.nearmax = bi;\n                }\n            }\n            return acc;\n        };\n\n        coefSelectionFunc = function(i) {\n            return i < n && a[i] < 0;\n        };\n\n        // eslint-disable-next-line unicorn/no-fn-reference-in-iterator\n        const max_nearmax_pos = b.reduce(find2Max, {max: 0, nearmax: 0});\n\n        coefSelectionFunc = function(i) {\n            return i < n && ((n % 2 === i % 2) ? a[i] < 0 : a[i] > 0);\n        };\n\n        // eslint-disable-next-line unicorn/no-fn-reference-in-iterator\n        const max_nearmax_neg = b.reduce(find2Max, {max: 0, nearmax: 0});\n\n        return {\n            negX: -2 * max_nearmax_neg.max,\n            posX: 2 * max_nearmax_pos.max\n        };\n    }\n\n    /**\n     *  Calculates lower Real roots bounds. <br/>\n     *  There are no Real roots in interval <negX, posX>. Determined by Fujiwara method.\n     *  @see {@link http://en.wikipedia.org/wiki/Properties_of_polynomial_roots}\n     *\n     *  @returns {{ negX: number, posX: number }}\n     */\n    bounds_LowerReal_Fujiwara() {\n        const poly = new Polynomial();\n\n        poly.coefs = this.coefs.slice().reverse();\n\n        const res = poly.bounds_UpperReal_Fujiwara();\n\n        res.negX = 1 / res.negX;\n        res.posX = 1 / res.posX;\n\n        return res;\n    }\n\n    /**\n     *  Calculates left and right Real roots bounds. <br/>\n     *  Real roots are in interval [minX, maxX]. Combines Fujiwara lower and upper bounds to get minimal interval.\n     *  @see {@link http://en.wikipedia.org/wiki/Properties_of_polynomial_roots}\n     *\n     *  @returns {{ minX: number, maxX: number }}\n    */\n    bounds() {\n        const urb = this.bounds_UpperReal_Fujiwara();\n        const rb = {minX: urb.negX, maxX: urb.posX};\n\n        if (urb.negX === 0 && urb.posX === 0) {\n            return rb;\n        }\n\n        if (urb.negX === 0) {\n            rb.minX = this.bounds_LowerReal_Fujiwara().posX;\n        }\n        else if (urb.posX === 0) {\n            rb.maxX = this.bounds_LowerReal_Fujiwara().negX;\n        }\n\n        if (rb.minX > rb.maxX) {\n            rb.minX = rb.maxX = 0;\n        }\n\n        return rb;\n        // TODO: if sure that there are no complex roots\n        // (maybe by using Sturm's theorem) use:\n        // return this.bounds_Real_Laguerre();\n    }\n\n    /**\n     *  Sets small coefficients to zero.\n     *\n     *  @returns {module:kld-polynomial.Polynomial}\n     */\n    modify_zeroSmallCoefs() {\n        const c = this.coefs;\n        const ERRF = 1e-15;\n        const err = 10 * ERRF * Math.abs(\n            c.reduce((pv, cv) => {\n                return Math.abs(cv) > Math.abs(pv) ? cv : pv;\n            })\n        );\n\n        for (let i = 0; i < c.length - 1; i++) {\n            if (Math.abs(c[i]) < err) {\n                c[i] = 0;\n            }\n        }\n\n        return this;\n    }\n\n\n    /**\n     *  Scales polynomial so that leading coefficient becomes 1.\n     *\n     *  @returns {module:kld-polynomial.Polynomial}\n     */\n    modify_toMonic() {\n        const c = this.coefs;\n\n        if (c[c.length - 1] !== 1) {\n            this.divide_scalar(c[c.length - 1]);\n        }\n\n        return this;\n    }\n\n\n    /**\n     *  Calculates absolute upper roots bound. <br/>\n     *  All (Complex and Real) roots magnitudes are &lt;= result. Determined by Rouche method.\n     *  @see {@link http://en.wikipedia.org/wiki/Properties_of_polynomial_roots}\n     *  @returns {number}\n     */\n    bound_UpperAbs_Rouche() {\n        const a = this.coefs;\n        const n = a.length - 1;\n        const max = a.reduce((prev, curr, i) => {\n            if (i !== n) {\n                curr = Math.abs(curr);\n                return (prev < curr) ? curr : prev;\n            }\n            return prev;\n        }, 0);\n\n        return 1 + max / Math.abs(a[n]);\n    }\n\n\n    /**\n     *  Calculates absolute lower roots bound. <br/>\n     *  All (Complex and Real) roots magnitudes are &gt;= result. Determined by Rouche method.\n     *  @see {@link http://en.wikipedia.org/wiki/Properties_of_polynomial_roots}\n     *  @returns {number}\n     */\n    bound_LowerAbs_Rouche() {\n        const a = this.coefs;\n        const max = a.reduce((prev, curr, i) => {\n            if (i !== 0) {\n                curr = Math.abs(curr);\n                return (prev < curr) ? curr : prev;\n            }\n            return prev;\n        }, 0);\n\n        return Math.abs(a[0]) / (Math.abs(a[0]) + max);\n    }\n\n\n    /**\n     *  Calculates left and right Real roots bounds. <br/>\n     *  WORKS ONLY if all polynomial roots are Real.\n     *  Real roots are in interval [minX, maxX]. Determined by Laguerre method.\n     *  @see {@link http://en.wikipedia.org/wiki/Properties_of_polynomial_roots}\n     *  @returns {{ minX: number, maxX: number }}\n     */\n    bounds_Real_Laguerre() {\n        const a = this.coefs;\n        const n = a.length - 1;\n        const p1 = -a[n - 1] / (n * a[n]);\n        const undersqrt = a[n - 1] * a[n - 1] - 2 * n / (n - 1) * a[n] * a[n - 2];\n        let p2 = (n - 1) / (n * a[n]) * Math.sqrt(undersqrt);\n\n        if (p2 < 0) {\n            p2 = -p2;\n        }\n\n        return {\n            minX: p1 - p2,\n            maxX: p1 + p2\n        };\n    }\n\n\n    /**\n     *  Root count by Descartes rule of signs. <br/>\n     *  Returns maximum number of positive and negative real roots and minimum number of complex roots.\n     *  @see {@link http://en.wikipedia.org/wiki/Descartes%27_rule_of_signs}\n     *  @returns {{maxRealPos: number, maxRealNeg: number, minComplex: number}}\n     */\n    countRoots_Descartes() {\n        const a = this.coefs;\n        const n = a.length - 1;\n        const accum = a.reduce((acc, ai, i) => {\n            if (acc.prev_a !== 0 && ai !== 0) {\n                if ((acc.prev_a < 0) === (ai > 0)) {\n                    acc.pos++;\n                }\n                if (((i % 2 === 0) !== (acc.prev_a < 0)) === ((i % 2 === 1) !== (ai > 0))) {\n                    acc.neg++;\n                }\n            }\n            acc.prev_a = ai;\n            return acc;\n        }, {pos: 0, neg: 0, prev_a: 0});\n\n        return {\n            maxRealPos: accum.pos,\n            maxRealNeg: accum.neg,\n            minComplex: n - (accum.pos + accum.neg)\n        };\n    }\n}\n\nPolynomial.TOLERANCE = 1e-6;\nPolynomial.ACCURACY = 15;\n\nexport default Polynomial;\n","/**\n *\n *   IntersectionArgs.js\n *\n *   @copyright 2002, 2017 Kevin Lindsey\n *\n */\n\n/**\n *  IntersectionArgs\n * @memberof module:kld-intersections\n */\nclass IntersectionArgs {\n    /**\n     *  @param {string} name\n     *  @param {Array<module:kld-intersections.Point2D>} args\n     *  @returns {module:kld-intersections.IntersectionArgs}\n     */\n    constructor(name, args) {\n        this.init(name, args);\n    }\n    /**\n     *  init\n     *\n     *  @param {string} name\n     *  @param {Array<module:kld-intersections.Point2D>} args\n     */\n    init(name, args) {\n        this.name = name;\n        this.args = args;\n    }\n}\n\nexport default IntersectionArgs;\n","/* eslint-disable camelcase, no-labels */\n/**\n *\n *  Intersection.js\n *\n *  copyright 2002, 2013 Kevin Lindsey\n */\n\nimport {Point2D, Vector2D} from \"kld-affine\";\nimport {Polynomial} from \"kld-polynomial\";\nimport IntersectionArgs from \"./IntersectionArgs.js\";\n\nconst TWO_PI = 2.0 * Math.PI;\nconst UNIT_X = new Vector2D(1, 0);\n\n/**\n * @memberof module:kld-intersections.Intersection~\n * @param {*} o\n * @returns {boolean}\n */\nfunction isNullish(o) {\n    return o === null || o === undefined;\n}\n\n/**\n *  bezout\n *\n *  This code is based on MgcIntr2DElpElp.cpp written by David Eberly.  His\n *  code along with many other excellent examples are avaiable at his site:\n *  http://www.magic-software.com\n *\n *  @param {Array<module:kld-intersections.Point2D>} e1\n *  @param {Array<module:kld-intersections.Point2D>} e2\n *  @returns {external:Polynomial}\n */\nfunction bezout(e1, e2) {\n    const AB = e1[0] * e2[1] - e2[0] * e1[1];\n    const AC = e1[0] * e2[2] - e2[0] * e1[2];\n    const AD = e1[0] * e2[3] - e2[0] * e1[3];\n    const AE = e1[0] * e2[4] - e2[0] * e1[4];\n    const AF = e1[0] * e2[5] - e2[0] * e1[5];\n    const BC = e1[1] * e2[2] - e2[1] * e1[2];\n    const BE = e1[1] * e2[4] - e2[1] * e1[4];\n    const BF = e1[1] * e2[5] - e2[1] * e1[5];\n    const CD = e1[2] * e2[3] - e2[2] * e1[3];\n    const DE = e1[3] * e2[4] - e2[3] * e1[4];\n    const DF = e1[3] * e2[5] - e2[3] * e1[5];\n    const BFpDE = BF + DE;\n    const BEmCD = BE - CD;\n\n    return new Polynomial(\n        AB * BC - AC * AC,\n        AB * BEmCD + AD * BC - 2 * AC * AE,\n        AB * BFpDE + AD * BEmCD - AE * AE - 2 * AC * AF,\n        AB * DF + AD * BFpDE - 2 * AE * AF,\n        AD * DF - AF * AF\n    );\n}\n\n/**\n * normalizeAngle\n *\n * @param {number} radians\n * @returns {number}\n */\nfunction normalizeAngle(radians) {\n    const normal = radians % TWO_PI;\n\n    return normal < 0.0 ? normal + TWO_PI : normal;\n}\n\n/**\n * restrictPointsToArc\n *\n * @param {module:kld-intersections.Intersection} intersections\n * @param {module:kld-intersections.Point2D} center\n * @param {number} radiusX\n * @param {number} radiusY\n * @param {number} startRadians\n * @param {number} endRadians\n * @returns {module:kld-intersections.Intersection}\n */\nfunction restrictPointsToArc(intersections, center, radiusX, radiusY, startRadians, endRadians) {\n    if (intersections.points.length === 0) {\n        return intersections;\n    }\n\n    const result = new Intersection(\"No Intersection\");\n    const startNormal = normalizeAngle(startRadians);\n    const endNormal = normalizeAngle(endRadians);\n\n    for (const p of intersections.points) {\n        const a = normalizeAngle(UNIT_X.angleBetween(Vector2D.fromPoints(center, p)));\n\n        if (startNormal <= a && a <= endNormal) {\n            result.appendPoint(p);\n        }\n    }\n\n    if (result.points.length > 0) {\n        result.status = \"Intersection\";\n    }\n\n    return result;\n}\n\n/**\n *  closePolygon\n *  @memberof module:kld-intersections.Intersection~\n *  @param {Array<module:kld-intersections.Point2D>} points\n *  @returns {Array<module:kld-intersections.Point2D>}\n */\nfunction closePolygon(points) {\n    const copy = points.slice();\n\n    copy.push(points[0]);\n\n    return copy;\n}\n\n/**\n * Intersection\n * @memberof module:kld-intersections\n */\nclass Intersection {\n    /**\n     *  @param {string} status\n     *  @returns {module:kld-intersections.Intersection}\n     */\n    constructor(status) {\n        this.init(status);\n    }\n\n\n    /**\n     *  init\n     *\n     *  @param {string} status\n     *  @returns {module:kld-intersections.Intersection}\n     */\n    init(status) {\n        this.status = status;\n        this.points = [];\n    }\n\n    /**\n     *  intersect\n     *\n     *  @param {module:kld-intersections.IntersectionArgs} shape1\n     *  @param {module:kld-intersections.IntersectionArgs} shape2\n     *  @returns {module:kld-intersections.Intersection}\n     */\n    static intersect(shape1, shape2) {\n        let result;\n\n        if (!isNullish(shape1) && !isNullish(shape2)) {\n            if (shape1.name === \"Path\") {\n                result = Intersection.intersectPathShape(shape1, shape2);\n            }\n            else if (shape2.name === \"Path\") {\n                result = Intersection.intersectPathShape(shape2, shape1);\n            }\n            else if (shape1.name === \"Arc\") {\n                result = Intersection.intersectArcShape(shape1, shape2);\n            }\n            else if (shape2.name === \"Arc\") {\n                result = Intersection.intersectArcShape(shape2, shape1);\n            }\n            else {\n                let method;\n                let args;\n\n                if (shape1.name < shape2.name) {\n                    method = \"intersect\" + shape1.name + shape2.name;\n                    args = shape1.args.concat(shape2.args);\n                }\n                else {\n                    method = \"intersect\" + shape2.name + shape1.name;\n                    args = shape2.args.concat(shape1.args);\n                }\n\n                if (!(method in Intersection)) {\n                    throw new Error(\"Intersection not available: \" + method);\n                }\n\n                result = Intersection[method].apply(null, args);\n            }\n        }\n        else {\n            result = new Intersection(\"No Intersection\");\n        }\n\n        return result;\n    }\n\n    /**\n     *  intersectPathShape\n     *\n     *  @param {module:kld-intersections.IntersectionArgs} path\n     *  @param {module:kld-intersections.IntersectionArgs} shape\n     *  @returns {module:kld-intersections.Intersection}\n     */\n    static intersectPathShape(path, shape) {\n        const result = new Intersection(\"No Intersection\");\n\n        for (const segment of path.args) {\n            const inter = Intersection.intersect(segment, shape);\n\n            result.appendPoints(inter.points);\n        }\n\n        if (result.points.length > 0) {\n            result.status = \"Intersection\";\n        }\n\n        return result;\n    }\n\n    /**\n     * intersectArcShape\n     *\n     * @param {module:kld-intersections.IntersectionArgs} arc\n     * @param {module:kld-intersections.IntersectionArgs} shape\n     * @returns {module:kld-intersections.Intersection}\n     */\n    static intersectArcShape(arc, shape) {\n        const [center, radiusX, radiusY, startRadians, endRadians] = arc.args;\n        const ellipse = new IntersectionArgs(\"Ellipse\", [center, radiusX, radiusY]);\n        const ellipse_result = Intersection.intersect(ellipse, shape);\n\n        // return ellipse_result;\n        return restrictPointsToArc(ellipse_result, center, radiusX, radiusY, startRadians, endRadians);\n    }\n\n    /**\n     *  intersectBezier2Bezier2\n     *\n     *  @param {module:kld-intersections.Point2D} a1\n     *  @param {module:kld-intersections.Point2D} a2\n     *  @param {module:kld-intersections.Point2D} a3\n     *  @param {module:kld-intersections.Point2D} b1\n     *  @param {module:kld-intersections.Point2D} b2\n     *  @param {module:kld-intersections.Point2D} b3\n     *  @returns {module:kld-intersections.Intersection}\n     */\n    static intersectBezier2Bezier2(a1, a2, a3, b1, b2, b3) {\n        let a, b;\n        const result = new Intersection(\"No Intersection\");\n\n        a = a2.multiply(-2);\n        const c12 = a1.add(a.add(a3));\n\n        a = a1.multiply(-2);\n        b = a2.multiply(2);\n        const c11 = a.add(b);\n\n        const c10 = new Point2D(a1.x, a1.y);\n\n        a = b2.multiply(-2);\n        const c22 = b1.add(a.add(b3));\n\n        a = b1.multiply(-2);\n        b = b2.multiply(2);\n        const c21 = a.add(b);\n\n        const c20 = new Point2D(b1.x, b1.y);\n\n        // bezout\n        a = c12.x * c11.y - c11.x * c12.y;\n        b = c22.x * c11.y - c11.x * c22.y;\n        const c = c21.x * c11.y - c11.x * c21.y;\n        const d = c11.x * (c10.y - c20.y) + c11.y * (-c10.x + c20.x);\n        const e = c22.x * c12.y - c12.x * c22.y;\n        const f = c21.x * c12.y - c12.x * c21.y;\n        const g = c12.x * (c10.y - c20.y) + c12.y * (-c10.x + c20.x);\n\n        // determinant\n        const poly = new Polynomial(\n            -e * e,\n            -2 * e * f,\n            a * b - f * f - 2 * e * g,\n            a * c - 2 * f * g,\n            a * d - g * g\n        );\n\n        const roots = poly.getRoots();\n\n        for (const s of roots) {\n            if (0 <= s && s <= 1) {\n                const xp = new Polynomial(\n                    c12.x,\n                    c11.x,\n                    c10.x - c20.x - s * c21.x - s * s * c22.x\n                );\n                xp.simplify();\n                const xRoots = xp.getRoots();\n                const yp = new Polynomial(\n                    c12.y,\n                    c11.y,\n                    c10.y - c20.y - s * c21.y - s * s * c22.y\n                );\n                yp.simplify();\n                const yRoots = yp.getRoots();\n\n                if (xRoots.length > 0 && yRoots.length > 0) {\n                    const TOLERANCE = 1e-4;\n\n                    checkRoots:\n                    for (const xRoot of xRoots) {\n                        if (0 <= xRoot && xRoot <= 1) {\n                            for (let k = 0; k < yRoots.length; k++) {\n                                if (Math.abs(xRoot - yRoots[k]) < TOLERANCE) {\n                                    result.points.push(c22.multiply(s * s).add(c21.multiply(s).add(c20)));\n                                    break checkRoots;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        if (result.points.length > 0) {\n            result.status = \"Intersection\";\n        }\n\n        return result;\n    }\n\n    /**\n     *  intersectBezier2Bezier3\n     *\n     *  @param {module:kld-intersections.Point2D} a1\n     *  @param {module:kld-intersections.Point2D} a2\n     *  @param {module:kld-intersections.Point2D} a3\n     *  @param {module:kld-intersections.Point2D} b1\n     *  @param {module:kld-intersections.Point2D} b2\n     *  @param {module:kld-intersections.Point2D} b3\n     *  @param {module:kld-intersections.Point2D} b4\n     *  @returns {module:kld-intersections.Intersection}\n     */\n    static intersectBezier2Bezier3(a1, a2, a3, b1, b2, b3, b4) {\n        let a, b, c, d;\n        const result = new Intersection(\"No Intersection\");\n\n        a = a2.multiply(-2);\n        const c12 = a1.add(a.add(a3));\n\n        a = a1.multiply(-2);\n        b = a2.multiply(2);\n        const c11 = a.add(b);\n\n        const c10 = new Point2D(a1.x, a1.y);\n\n        a = b1.multiply(-1);\n        b = b2.multiply(3);\n        c = b3.multiply(-3);\n        d = a.add(b.add(c.add(b4)));\n        const c23 = new Vector2D(d.x, d.y);\n\n        a = b1.multiply(3);\n        b = b2.multiply(-6);\n        c = b3.multiply(3);\n        d = a.add(b.add(c));\n        const c22 = new Vector2D(d.x, d.y);\n\n        a = b1.multiply(-3);\n        b = b2.multiply(3);\n        c = a.add(b);\n        const c21 = new Vector2D(c.x, c.y);\n\n        const c20 = new Vector2D(b1.x, b1.y);\n\n        const c10x2 = c10.x * c10.x;\n        const c10y2 = c10.y * c10.y;\n        const c11x2 = c11.x * c11.x;\n        const c11y2 = c11.y * c11.y;\n        const c12x2 = c12.x * c12.x;\n        const c12y2 = c12.y * c12.y;\n        const c20x2 = c20.x * c20.x;\n        const c20y2 = c20.y * c20.y;\n        const c21x2 = c21.x * c21.x;\n        const c21y2 = c21.y * c21.y;\n        const c22x2 = c22.x * c22.x;\n        const c22y2 = c22.y * c22.y;\n        const c23x2 = c23.x * c23.x;\n        const c23y2 = c23.y * c23.y;\n\n        const poly = new Polynomial(\n            -2 * c12.x * c12.y * c23.x * c23.y + c12x2 * c23y2 + c12y2 * c23x2,\n            -2 * c12.x * c12.y * c22.x * c23.y - 2 * c12.x * c12.y * c22.y * c23.x + 2 * c12y2 * c22.x * c23.x +\n                2 * c12x2 * c22.y * c23.y,\n            -2 * c12.x * c21.x * c12.y * c23.y - 2 * c12.x * c12.y * c21.y * c23.x - 2 * c12.x * c12.y * c22.x * c22.y +\n                2 * c21.x * c12y2 * c23.x + c12y2 * c22x2 + c12x2 * (2 * c21.y * c23.y + c22y2),\n            2 * c10.x * c12.x * c12.y * c23.y + 2 * c10.y * c12.x * c12.y * c23.x + c11.x * c11.y * c12.x * c23.y +\n                c11.x * c11.y * c12.y * c23.x - 2 * c20.x * c12.x * c12.y * c23.y - 2 * c12.x * c20.y * c12.y * c23.x -\n                2 * c12.x * c21.x * c12.y * c22.y - 2 * c12.x * c12.y * c21.y * c22.x - 2 * c10.x * c12y2 * c23.x -\n                2 * c10.y * c12x2 * c23.y + 2 * c20.x * c12y2 * c23.x + 2 * c21.x * c12y2 * c22.x -\n                c11y2 * c12.x * c23.x - c11x2 * c12.y * c23.y + c12x2 * (2 * c20.y * c23.y + 2 * c21.y * c22.y),\n            2 * c10.x * c12.x * c12.y * c22.y + 2 * c10.y * c12.x * c12.y * c22.x + c11.x * c11.y * c12.x * c22.y +\n                c11.x * c11.y * c12.y * c22.x - 2 * c20.x * c12.x * c12.y * c22.y - 2 * c12.x * c20.y * c12.y * c22.x -\n                2 * c12.x * c21.x * c12.y * c21.y - 2 * c10.x * c12y2 * c22.x - 2 * c10.y * c12x2 * c22.y +\n                2 * c20.x * c12y2 * c22.x - c11y2 * c12.x * c22.x - c11x2 * c12.y * c22.y + c21x2 * c12y2 +\n                c12x2 * (2 * c20.y * c22.y + c21y2),\n            2 * c10.x * c12.x * c12.y * c21.y + 2 * c10.y * c12.x * c21.x * c12.y + c11.x * c11.y * c12.x * c21.y +\n                c11.x * c11.y * c21.x * c12.y - 2 * c20.x * c12.x * c12.y * c21.y - 2 * c12.x * c20.y * c21.x * c12.y -\n                2 * c10.x * c21.x * c12y2 - 2 * c10.y * c12x2 * c21.y + 2 * c20.x * c21.x * c12y2 -\n                c11y2 * c12.x * c21.x - c11x2 * c12.y * c21.y + 2 * c12x2 * c20.y * c21.y,\n            -2 * c10.x * c10.y * c12.x * c12.y - c10.x * c11.x * c11.y * c12.y - c10.y * c11.x * c11.y * c12.x +\n                2 * c10.x * c12.x * c20.y * c12.y + 2 * c10.y * c20.x * c12.x * c12.y + c11.x * c20.x * c11.y * c12.y +\n                c11.x * c11.y * c12.x * c20.y - 2 * c20.x * c12.x * c20.y * c12.y - 2 * c10.x * c20.x * c12y2 +\n                c10.x * c11y2 * c12.x + c10.y * c11x2 * c12.y - 2 * c10.y * c12x2 * c20.y -\n                c20.x * c11y2 * c12.x - c11x2 * c20.y * c12.y + c10x2 * c12y2 + c10y2 * c12x2 +\n                c20x2 * c12y2 + c12x2 * c20y2\n        );\n        const roots = poly.getRootsInInterval(0, 1);\n\n        for (const s of roots) {\n            const xRoots = new Polynomial(\n                c12.x,\n                c11.x,\n                c10.x - c20.x - s * c21.x - s * s * c22.x - s * s * s * c23.x\n            ).getRoots();\n            const yRoots = new Polynomial(\n                c12.y,\n                c11.y,\n                c10.y - c20.y - s * c21.y - s * s * c22.y - s * s * s * c23.y\n            ).getRoots();\n\n            if (xRoots.length > 0 && yRoots.length > 0) {\n                const TOLERANCE = 1e-4;\n\n                checkRoots:\n                for (const xRoot of xRoots) {\n                    if (0 <= xRoot && xRoot <= 1) {\n                        for (let k = 0; k < yRoots.length; k++) {\n                            if (Math.abs(xRoot - yRoots[k]) < TOLERANCE) {\n                                result.points.push(\n                                    c23.multiply(s * s * s).add(c22.multiply(s * s).add(c21.multiply(s).add(c20)))\n                                );\n                                break checkRoots;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        if (result.points.length > 0) {\n            result.status = \"Intersection\";\n        }\n\n        return result;\n    }\n\n    /**\n     *  intersectBezier2Circle\n     *\n     *  @param {module:kld-intersections.Point2D} p1\n     *  @param {module:kld-intersections.Point2D} p2\n     *  @param {module:kld-intersections.Point2D} p3\n     *  @param {module:kld-intersections.Point2D} c\n     *  @param {number} r\n     *  @returns {module:kld-intersections.Intersection}\n     */\n    static intersectBezier2Circle(p1, p2, p3, c, r) {\n        return Intersection.intersectBezier2Ellipse(p1, p2, p3, c, r, r);\n    }\n\n    /**\n     *  intersectBezier2Ellipse\n     *\n     *  @param {module:kld-intersections.Point2D} p1\n     *  @param {module:kld-intersections.Point2D} p2\n     *  @param {module:kld-intersections.Point2D} p3\n     *  @param {module:kld-intersections.Point2D} ec\n     *  @param {number} rx\n     *  @param {number} ry\n     *  @returns {module:kld-intersections.Intersection}\n     */\n    static intersectBezier2Ellipse(p1, p2, p3, ec, rx, ry) {\n        let a; // temporary variables\n        // c2, c1, c0; // coefficients of quadratic\n        const result = new Intersection(\"No Intersection\");\n\n        a = p2.multiply(-2);\n        const c2 = p1.add(a.add(p3));\n\n        a = p1.multiply(-2);\n        const b = p2.multiply(2);\n        const c1 = a.add(b);\n\n        const c0 = new Point2D(p1.x, p1.y);\n\n        const rxrx = rx * rx;\n        const ryry = ry * ry;\n        const roots = new Polynomial(\n            ryry * c2.x * c2.x + rxrx * c2.y * c2.y,\n            2 * (ryry * c2.x * c1.x + rxrx * c2.y * c1.y),\n            ryry * (2 * c2.x * c0.x + c1.x * c1.x) + rxrx * (2 * c2.y * c0.y + c1.y * c1.y) -\n                2 * (ryry * ec.x * c2.x + rxrx * ec.y * c2.y),\n            2 * (ryry * c1.x * (c0.x - ec.x) + rxrx * c1.y * (c0.y - ec.y)),\n            ryry * (c0.x * c0.x + ec.x * ec.x) + rxrx * (c0.y * c0.y + ec.y * ec.y) -\n                2 * (ryry * ec.x * c0.x + rxrx * ec.y * c0.y) - rxrx * ryry\n        ).getRoots();\n\n        for (const t of roots) {\n            if (0 <= t && t <= 1) {\n                result.points.push(c2.multiply(t * t).add(c1.multiply(t).add(c0)));\n            }\n        }\n\n        if (result.points.length > 0) {\n            result.status = \"Intersection\";\n        }\n\n        return result;\n    }\n\n    /**\n     *  intersectBezier2Line\n     *\n     *  @param {module:kld-intersections.Point2D} p1\n     *  @param {module:kld-intersections.Point2D} p2\n     *  @param {module:kld-intersections.Point2D} p3\n     *  @param {module:kld-intersections.Point2D} a1\n     *  @param {module:kld-intersections.Point2D} a2\n     *  @returns {module:kld-intersections.Intersection}\n     */\n    static intersectBezier2Line(p1, p2, p3, a1, a2) {\n        let a; // temporary variables\n        // let c2, c1, c0; // coefficients of quadratic\n        // cl; // c coefficient for normal form of line\n        // n; // normal for normal form of line\n        const min = a1.min(a2); // used to determine if point is on line segment\n        const max = a1.max(a2); // used to determine if point is on line segment\n        const result = new Intersection(\"No Intersection\");\n\n        a = p2.multiply(-2);\n        const c2 = p1.add(a.add(p3));\n\n        a = p1.multiply(-2);\n        const b = p2.multiply(2);\n        const c1 = a.add(b);\n\n        const c0 = new Point2D(p1.x, p1.y);\n\n        // Convert line to normal form: ax + by + c = 0\n        // Find normal to line: negative inverse of original line's slope\n        const n = new Vector2D(a1.y - a2.y, a2.x - a1.x);\n\n        // Determine new c coefficient\n        const cl = a1.x * a2.y - a2.x * a1.y;\n\n        // Transform cubic coefficients to line's coordinate system and find roots\n        // of cubic\n        const roots = new Polynomial(\n            n.dot(c2),\n            n.dot(c1),\n            n.dot(c0) + cl\n        ).getRoots();\n\n        // Any roots in closed interval [0,1] are intersections on Bezier, but\n        // might not be on the line segment.\n        // Find intersections and calculate point coordinates\n        for (const t of roots) {\n            if (0 <= t && t <= 1) {\n                // We're within the Bezier curve\n                // Find point on Bezier\n                const p4 = p1.lerp(p2, t);\n                const p5 = p2.lerp(p3, t);\n\n                const p6 = p4.lerp(p5, t);\n\n                // See if point is on line segment\n                // Had to make special cases for vertical and horizontal lines due\n                // to slight errors in calculation of p6\n                if (a1.x === a2.x) {\n                    if (min.y <= p6.y && p6.y <= max.y) {\n                        result.status = \"Intersection\";\n                        result.appendPoint(p6);\n                    }\n                }\n                else if (a1.y === a2.y) {\n                    if (min.x <= p6.x && p6.x <= max.x) {\n                        result.status = \"Intersection\";\n                        result.appendPoint(p6);\n                    }\n                }\n                else if (min.x <= p6.x && p6.x <= max.x && min.y <= p6.y && p6.y <= max.y) {\n                    result.status = \"Intersection\";\n                    result.appendPoint(p6);\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     *  intersectBezier2Polygon\n     *\n     *  @param {module:kld-intersections.Point2D} p1\n     *  @param {module:kld-intersections.Point2D} p2\n     *  @param {module:kld-intersections.Point2D} p3\n     *  @param {Array<module:kld-intersections.Point2D>} points\n     *  @returns {module:kld-intersections.Intersection}\n     */\n    static intersectBezier2Polygon(p1, p2, p3, points) {\n        return Intersection.intersectBezier2Polyline(p1, p2, p3, closePolygon(points));\n    }\n\n    /**\n     *  intersectBezier2Polyline\n     *\n     *  @param {module:kld-intersections.Point2D} p1\n     *  @param {module:kld-intersections.Point2D} p2\n     *  @param {module:kld-intersections.Point2D} p3\n     *  @param {Array<module:kld-intersections.Point2D>} points\n     *  @returns {module:kld-intersections.Intersection}\n     */\n    static intersectBezier2Polyline(p1, p2, p3, points) {\n        const result = new Intersection(\"No Intersection\");\n        const {length: len} = points;\n\n        for (let i = 0; i < len - 1; i++) {\n            const a1 = points[i];\n            const a2 = points[i + 1];\n            const inter = Intersection.intersectBezier2Line(p1, p2, p3, a1, a2);\n\n            result.appendPoints(inter.points);\n        }\n\n        if (result.points.length > 0) {\n            result.status = \"Intersection\";\n        }\n\n        return result;\n    }\n\n    /**\n     *  intersectBezier2Rectangle\n     *\n     *  @param {module:kld-intersections.Point2D} p1\n     *  @param {module:kld-intersections.Point2D} p2\n     *  @param {module:kld-intersections.Point2D} p3\n     *  @param {module:kld-intersections.Point2D} r1\n     *  @param {module:kld-intersections.Point2D} r2\n     *  @returns {module:kld-intersections.Intersection}\n     */\n    static intersectBezier2Rectangle(p1, p2, p3, r1, r2) {\n        const min = r1.min(r2);\n        const max = r1.max(r2);\n        const topRight = new Point2D(max.x, min.y);\n        const bottomLeft = new Point2D(min.x, max.y);\n\n        const inter1 = Intersection.intersectBezier2Line(p1, p2, p3, min, topRight);\n        const inter2 = Intersection.intersectBezier2Line(p1, p2, p3, topRight, max);\n        const inter3 = Intersection.intersectBezier2Line(p1, p2, p3, max, bottomLeft);\n        const inter4 = Intersection.intersectBezier2Line(p1, p2, p3, bottomLeft, min);\n\n        const result = new Intersection(\"No Intersection\");\n\n        result.appendPoints(inter1.points);\n        result.appendPoints(inter2.points);\n        result.appendPoints(inter3.points);\n        result.appendPoints(inter4.points);\n\n        if (result.points.length > 0) {\n            result.status = \"Intersection\";\n        }\n\n        return result;\n    }\n\n    /**\n     *  intersectBezier3Bezier3\n     *\n     *  @param {module:kld-intersections.Point2D} a1\n     *  @param {module:kld-intersections.Point2D} a2\n     *  @param {module:kld-intersections.Point2D} a3\n     *  @param {module:kld-intersections.Point2D} a4\n     *  @param {module:kld-intersections.Point2D} b1\n     *  @param {module:kld-intersections.Point2D} b2\n     *  @param {module:kld-intersections.Point2D} b3\n     *  @param {module:kld-intersections.Point2D} b4\n     *  @returns {module:kld-intersections.Intersection}\n     */\n    static intersectBezier3Bezier3(a1, a2, a3, a4, b1, b2, b3, b4) {\n        let a, b, c, d; // temporary variables\n        // c13, c12, c11, c10; // coefficients of cubic\n        // c23, c22, c21, c20; // coefficients of cubic\n        const result = new Intersection(\"No Intersection\");\n\n        // Calculate the coefficients of cubic polynomial\n        a = a1.multiply(-1);\n        b = a2.multiply(3);\n        c = a3.multiply(-3);\n        d = a.add(b.add(c.add(a4)));\n        const c13 = new Vector2D(d.x, d.y);\n\n        a = a1.multiply(3);\n        b = a2.multiply(-6);\n        c = a3.multiply(3);\n        d = a.add(b.add(c));\n        const c12 = new Vector2D(d.x, d.y);\n\n        a = a1.multiply(-3);\n        b = a2.multiply(3);\n        c = a.add(b);\n        const c11 = new Vector2D(c.x, c.y);\n\n        const c10 = new Vector2D(a1.x, a1.y);\n\n        a = b1.multiply(-1);\n        b = b2.multiply(3);\n        c = b3.multiply(-3);\n        d = a.add(b.add(c.add(b4)));\n        const c23 = new Vector2D(d.x, d.y);\n\n        a = b1.multiply(3);\n        b = b2.multiply(-6);\n        c = b3.multiply(3);\n        d = a.add(b.add(c));\n        const c22 = new Vector2D(d.x, d.y);\n\n        a = b1.multiply(-3);\n        b = b2.multiply(3);\n        c = a.add(b);\n        const c21 = new Vector2D(c.x, c.y);\n\n        const c20 = new Vector2D(b1.x, b1.y);\n\n        // bezout\n        a = c13.x * c12.y - c12.x * c13.y;\n        b = c13.x * c11.y - c11.x * c13.y;\n        const c0 = c13.x * c10.y - c10.x * c13.y + c20.x * c13.y - c13.x * c20.y;\n        const c1 = c21.x * c13.y - c13.x * c21.y;\n        const c2 = c22.x * c13.y - c13.x * c22.y;\n        const c3 = c23.x * c13.y - c13.x * c23.y;\n        d = c13.x * c11.y - c11.x * c13.y;\n        const e0 = c13.x * c10.y + c12.x * c11.y - c11.x * c12.y - c10.x * c13.y + c20.x * c13.y - c13.x * c20.y;\n        const e1 = c21.x * c13.y - c13.x * c21.y;\n        const e2 = c22.x * c13.y - c13.x * c22.y;\n        const e3 = c23.x * c13.y - c13.x * c23.y;\n        const f0 = c12.x * c10.y - c10.x * c12.y + c20.x * c12.y - c12.x * c20.y;\n        const f1 = c21.x * c12.y - c12.x * c21.y;\n        const f2 = c22.x * c12.y - c12.x * c22.y;\n        const f3 = c23.x * c12.y - c12.x * c23.y;\n        const g0 = c13.x * c10.y - c10.x * c13.y + c20.x * c13.y - c13.x * c20.y;\n        const g1 = c21.x * c13.y - c13.x * c21.y;\n        const g2 = c22.x * c13.y - c13.x * c22.y;\n        const g3 = c23.x * c13.y - c13.x * c23.y;\n        const h0 = c12.x * c10.y - c10.x * c12.y + c20.x * c12.y - c12.x * c20.y;\n        const h1 = c21.x * c12.y - c12.x * c21.y;\n        const h2 = c22.x * c12.y - c12.x * c22.y;\n        const h3 = c23.x * c12.y - c12.x * c23.y;\n        const i0 = c11.x * c10.y - c10.x * c11.y + c20.x * c11.y - c11.x * c20.y;\n        const i1 = c21.x * c11.y - c11.x * c21.y;\n        const i2 = c22.x * c11.y - c11.x * c22.y;\n        const i3 = c23.x * c11.y - c11.x * c23.y;\n\n        // determinant\n        const poly = new Polynomial(\n            -c3 * e3 * g3,\n            -c3 * e3 * g2 - c3 * e2 * g3 - c2 * e3 * g3,\n            -c3 * e3 * g1 - c3 * e2 * g2 - c2 * e3 * g2 - c3 * e1 * g3 - c2 * e2 * g3 - c1 * e3 * g3,\n            -c3 * e3 * g0 - c3 * e2 * g1 - c2 * e3 * g1 - c3 * e1 * g2 - c2 * e2 * g2 - c1 * e3 * g2 - c3 * e0 * g3 - c2 * e1 * g3 - c1 * e2 * g3 - c0 * e3 * g3 + b * f3 * g3 + c3 * d * h3 - a * f3 * h3 + a * e3 * i3,\n            -c3 * e2 * g0 - c2 * e3 * g0 - c3 * e1 * g1 - c2 * e2 * g1 - c1 * e3 * g1 - c3 * e0 * g2 - c2 * e1 * g2 - c1 * e2 * g2 - c0 * e3 * g2 + b * f3 * g2 - c2 * e0 * g3 - c1 * e1 * g3 - c0 * e2 * g3 + b * f2 * g3 + c3 * d * h2 - a * f3 * h2 + c2 * d * h3 - a * f2 * h3 + a * e3 * i2 + a * e2 * i3,\n            -c3 * e1 * g0 - c2 * e2 * g0 - c1 * e3 * g0 - c3 * e0 * g1 - c2 * e1 * g1 - c1 * e2 * g1 - c0 * e3 * g1 + b * f3 * g1 - c2 * e0 * g2 - c1 * e1 * g2 - c0 * e2 * g2 + b * f2 * g2 - c1 * e0 * g3 - c0 * e1 * g3 + b * f1 * g3 + c3 * d * h1 - a * f3 * h1 + c2 * d * h2 - a * f2 * h2 + c1 * d * h3 - a * f1 * h3 + a * e3 * i1 + a * e2 * i2 + a * e1 * i3,\n            -c3 * e0 * g0 - c2 * e1 * g0 - c1 * e2 * g0 - c0 * e3 * g0 + b * f3 * g0 - c2 * e0 * g1 - c1 * e1 * g1 - c0 * e2 * g1 + b * f2 * g1 - c1 * e0 * g2 - c0 * e1 * g2 + b * f1 * g2 - c0 * e0 * g3 + b * f0 * g3 + c3 * d * h0 - a * f3 * h0 + c2 * d * h1 - a * f2 * h1 + c1 * d * h2 - a * f1 * h2 + c0 * d * h3 - a * f0 * h3 + a * e3 * i0 + a * e2 * i1 + a * e1 * i2 - b * d * i3 + a * e0 * i3,\n            -c2 * e0 * g0 - c1 * e1 * g0 - c0 * e2 * g0 + b * f2 * g0 - c1 * e0 * g1 - c0 * e1 * g1 + b * f1 * g1 - c0 * e0 * g2 + b * f0 * g2 + c2 * d * h0 - a * f2 * h0 + c1 * d * h1 - a * f1 * h1 + c0 * d * h2 - a * f0 * h2 + a * e2 * i0 + a * e1 * i1 - b * d * i2 + a * e0 * i2,\n            -c1 * e0 * g0 - c0 * e1 * g0 + b * f1 * g0 - c0 * e0 * g1 + b * f0 * g1 + c1 * d * h0 - a * f1 * h0 + c0 * d * h1 - a * f0 * h1 + a * e1 * i0 - b * d * i1 + a * e0 * i1,\n            -c0 * e0 * g0 + b * f0 * g0 + c0 * d * h0 - a * f0 * h0 - b * d * i0 + a * e0 * i0\n        );\n        poly.simplify();\n        const roots = poly.getRootsInInterval(0, 1);\n\n        for (const s of roots) {\n            const xp = new Polynomial(\n                c13.x,\n                c12.x,\n                c11.x,\n                c10.x - c20.x - s * c21.x - s * s * c22.x - s * s * s * c23.x\n            );\n            xp.simplify();\n            const xRoots = xp.getRoots();\n            const yp = new Polynomial(\n                c13.y,\n                c12.y,\n                c11.y,\n                c10.y - c20.y - s * c21.y - s * s * c22.y - s * s * s * c23.y\n            );\n            yp.simplify();\n            const yRoots = yp.getRoots();\n\n            if (xRoots.length > 0 && yRoots.length > 0) {\n                const TOLERANCE = 1e-4;\n\n                checkRoots:\n                for (const xRoot of xRoots) {\n                    if (0 <= xRoot && xRoot <= 1) {\n                        for (let k = 0; k < yRoots.length; k++) {\n                            if (Math.abs(xRoot - yRoots[k]) < TOLERANCE) {\n                                result.points.push(\n                                    c23.multiply(s * s * s).add(c22.multiply(s * s).add(c21.multiply(s).add(c20)))\n                                );\n                                break checkRoots;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        if (result.points.length > 0) {\n            result.status = \"Intersection\";\n        }\n\n        return result;\n    }\n\n    /**\n     *  intersectBezier3Circle\n     *\n     *  @param {module:kld-intersections.Point2D} p1\n     *  @param {module:kld-intersections.Point2D} p2\n     *  @param {module:kld-intersections.Point2D} p3\n     *  @param {module:kld-intersections.Point2D} p4\n     *  @param {module:kld-intersections.Point2D} c\n     *  @param {number} r\n     *  @returns {module:kld-intersections.Intersection}\n     */\n    static intersectBezier3Circle(p1, p2, p3, p4, c, r) {\n        return Intersection.intersectBezier3Ellipse(p1, p2, p3, p4, c, r, r);\n    }\n\n    /**\n     *  intersectBezier3Ellipse\n     *\n     *  @param {module:kld-intersections.Point2D} p1\n     *  @param {module:kld-intersections.Point2D} p2\n     *  @param {module:kld-intersections.Point2D} p3\n     *  @param {module:kld-intersections.Point2D} p4\n     *  @param {module:kld-intersections.Point2D} ec\n     *  @param {number} rx\n     *  @param {number} ry\n     *  @returns {module:kld-intersections.Intersection}\n     */\n    static intersectBezier3Ellipse(p1, p2, p3, p4, ec, rx, ry) {\n        let a, b, c, d; // temporary variables\n        // c3, c2, c1, c0; // coefficients of cubic\n        const result = new Intersection(\"No Intersection\");\n\n        // Calculate the coefficients of cubic polynomial\n        a = p1.multiply(-1);\n        b = p2.multiply(3);\n        c = p3.multiply(-3);\n        d = a.add(b.add(c.add(p4)));\n        const c3 = new Vector2D(d.x, d.y);\n\n        a = p1.multiply(3);\n        b = p2.multiply(-6);\n        c = p3.multiply(3);\n        d = a.add(b.add(c));\n        const c2 = new Vector2D(d.x, d.y);\n\n        a = p1.multiply(-3);\n        b = p2.multiply(3);\n        c = a.add(b);\n        const c1 = new Vector2D(c.x, c.y);\n\n        const c0 = new Vector2D(p1.x, p1.y);\n\n        const rxrx = rx * rx;\n        const ryry = ry * ry;\n        const poly = new Polynomial(\n            c3.x * c3.x * ryry + c3.y * c3.y * rxrx,\n            2 * (c3.x * c2.x * ryry + c3.y * c2.y * rxrx),\n            2 * (c3.x * c1.x * ryry + c3.y * c1.y * rxrx) + c2.x * c2.x * ryry + c2.y * c2.y * rxrx,\n            2 * c3.x * ryry * (c0.x - ec.x) + 2 * c3.y * rxrx * (c0.y - ec.y) +\n                2 * (c2.x * c1.x * ryry + c2.y * c1.y * rxrx),\n            2 * c2.x * ryry * (c0.x - ec.x) + 2 * c2.y * rxrx * (c0.y - ec.y) +\n                c1.x * c1.x * ryry + c1.y * c1.y * rxrx,\n            2 * c1.x * ryry * (c0.x - ec.x) + 2 * c1.y * rxrx * (c0.y - ec.y),\n            c0.x * c0.x * ryry - 2 * c0.y * ec.y * rxrx - 2 * c0.x * ec.x * ryry +\n                c0.y * c0.y * rxrx + ec.x * ec.x * ryry + ec.y * ec.y * rxrx - rxrx * ryry\n        );\n        const roots = poly.getRootsInInterval(0, 1);\n\n        for (const t of roots) {\n            result.points.push(\n                c3.multiply(t * t * t).add(c2.multiply(t * t).add(c1.multiply(t).add(c0)))\n            );\n        }\n\n        if (result.points.length > 0) {\n            result.status = \"Intersection\";\n        }\n\n        return result;\n    }\n\n    /**\n     *  intersectBezier3Line\n     *\n     *  Many thanks to Dan Sunday at SoftSurfer.com.  He gave me a very thorough\n     *  sketch of the algorithm used here.  Without his help, I'm not sure when I\n     *  would have figured out this intersection problem.\n     *\n     *  @param {module:kld-intersections.Point2D} p1\n     *  @param {module:kld-intersections.Point2D} p2\n     *  @param {module:kld-intersections.Point2D} p3\n     *  @param {module:kld-intersections.Point2D} p4\n     *  @param {module:kld-intersections.Point2D} a1\n     *  @param {module:kld-intersections.Point2D} a2\n     *  @returns {module:kld-intersections.Intersection}\n     */\n    static intersectBezier3Line(p1, p2, p3, p4, a1, a2) {\n        let a, b, c, d; // temporary variables\n        // c3, c2, c1, c0; // coefficients of cubic\n        // cl; // c coefficient for normal form of line\n        // n; // normal for normal form of line\n        const min = a1.min(a2); // used to determine if point is on line segment\n        const max = a1.max(a2); // used to determine if point is on line segment\n        const result = new Intersection(\"No Intersection\");\n\n        // Start with Bezier using Bernstein polynomials for weighting functions:\n        //     (1-t^3)P1 + 3t(1-t)^2P2 + 3t^2(1-t)P3 + t^3P4\n        //\n        // Expand and collect terms to form linear combinations of original Bezier\n        // controls.  This ends up with a vector cubic in t:\n        //     (-P1+3P2-3P3+P4)t^3 + (3P1-6P2+3P3)t^2 + (-3P1+3P2)t + P1\n        //             /\\                  /\\                /\\       /\\\n        //             ||                  ||                ||       ||\n        //             c3                  c2                c1       c0\n\n        // Calculate the coefficients\n        a = p1.multiply(-1);\n        b = p2.multiply(3);\n        c = p3.multiply(-3);\n        d = a.add(b.add(c.add(p4)));\n        const c3 = new Vector2D(d.x, d.y);\n\n        a = p1.multiply(3);\n        b = p2.multiply(-6);\n        c = p3.multiply(3);\n        d = a.add(b.add(c));\n        const c2 = new Vector2D(d.x, d.y);\n\n        a = p1.multiply(-3);\n        b = p2.multiply(3);\n        c = a.add(b);\n        const c1 = new Vector2D(c.x, c.y);\n\n        const c0 = new Vector2D(p1.x, p1.y);\n\n        // Convert line to normal form: ax + by + c = 0\n        // Find normal to line: negative inverse of original line's slope\n        const n = new Vector2D(a1.y - a2.y, a2.x - a1.x);\n\n        // Determine new c coefficient\n        const cl = a1.x * a2.y - a2.x * a1.y;\n\n        // ?Rotate each cubic coefficient using line for new coordinate system?\n        // Find roots of rotated cubic\n        const roots = new Polynomial(\n            n.dot(c3),\n            n.dot(c2),\n            n.dot(c1),\n            n.dot(c0) + cl\n        ).getRoots();\n\n        // Any roots in closed interval [0,1] are intersections on Bezier, but\n        // might not be on the line segment.\n        // Find intersections and calculate point coordinates\n        for (const t of roots) {\n            if (0 <= t && t <= 1) {\n                // We're within the Bezier curve\n                // Find point on Bezier\n                const p5 = p1.lerp(p2, t);\n                const p6 = p2.lerp(p3, t);\n                const p7 = p3.lerp(p4, t);\n\n                const p8 = p5.lerp(p6, t);\n                const p9 = p6.lerp(p7, t);\n\n                const p10 = p8.lerp(p9, t);\n\n                // See if point is on line segment\n                // Had to make special cases for vertical and horizontal lines due\n                // to slight errors in calculation of p10\n                if (a1.x === a2.x) {\n                    if (min.y <= p10.y && p10.y <= max.y) {\n                        result.status = \"Intersection\";\n                        result.appendPoint(p10);\n                    }\n                }\n                else if (a1.y === a2.y) {\n                    if (min.x <= p10.x && p10.x <= max.x) {\n                        result.status = \"Intersection\";\n                        result.appendPoint(p10);\n                    }\n                }\n                else if (min.x <= p10.x && p10.x <= max.x && min.y <= p10.y && p10.y <= max.y) {\n                    result.status = \"Intersection\";\n                    result.appendPoint(p10);\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     *  intersectBezier3Polygon\n     *\n     *  @param {module:kld-intersections.Point2D} p1\n     *  @param {module:kld-intersections.Point2D} p2\n     *  @param {module:kld-intersections.Point2D} p3\n     *  @param {module:kld-intersections.Point2D} p4\n     *  @param {Array<module:kld-intersections.Point2D>} points\n     *  @returns {module:kld-intersections.Intersection}\n     */\n    static intersectBezier3Polygon(p1, p2, p3, p4, points) {\n        return Intersection.intersectBezier3Polyline(p1, p2, p3, p4, closePolygon(points));\n    }\n\n    /**\n     *  intersectBezier3Polyline\n     *\n     *  @param {module:kld-intersections.Point2D} p1\n     *  @param {module:kld-intersections.Point2D} p2\n     *  @param {module:kld-intersections.Point2D} p3\n     *  @param {module:kld-intersections.Point2D} p4\n     *  @param {Array<module:kld-intersections.Point2D>} points\n     *  @returns {module:kld-intersections.Intersection}\n     */\n    static intersectBezier3Polyline(p1, p2, p3, p4, points) {\n        const result = new Intersection(\"No Intersection\");\n        const {length: len} = points;\n\n        for (let i = 0; i < len - 1; i++) {\n            const a1 = points[i];\n            const a2 = points[i + 1];\n            const inter = Intersection.intersectBezier3Line(p1, p2, p3, p4, a1, a2);\n\n            result.appendPoints(inter.points);\n        }\n\n        if (result.points.length > 0) {\n            result.status = \"Intersection\";\n        }\n\n        return result;\n    }\n\n    /**\n     *  intersectBezier3Rectangle\n     *\n     *  @param {module:kld-intersections.Point2D} p1\n     *  @param {module:kld-intersections.Point2D} p2\n     *  @param {module:kld-intersections.Point2D} p3\n     *  @param {module:kld-intersections.Point2D} p4\n     *  @param {module:kld-intersections.Point2D} r1\n     *  @param {module:kld-intersections.Point2D} r2\n     *  @returns {module:kld-intersections.Intersection}\n     */\n    static intersectBezier3Rectangle(p1, p2, p3, p4, r1, r2) {\n        const min = r1.min(r2);\n        const max = r1.max(r2);\n        const topRight = new Point2D(max.x, min.y);\n        const bottomLeft = new Point2D(min.x, max.y);\n\n        const inter1 = Intersection.intersectBezier3Line(p1, p2, p3, p4, min, topRight);\n        const inter2 = Intersection.intersectBezier3Line(p1, p2, p3, p4, topRight, max);\n        const inter3 = Intersection.intersectBezier3Line(p1, p2, p3, p4, max, bottomLeft);\n        const inter4 = Intersection.intersectBezier3Line(p1, p2, p3, p4, bottomLeft, min);\n\n        const result = new Intersection(\"No Intersection\");\n\n        result.appendPoints(inter1.points);\n        result.appendPoints(inter2.points);\n        result.appendPoints(inter3.points);\n        result.appendPoints(inter4.points);\n\n        if (result.points.length > 0) {\n            result.status = \"Intersection\";\n        }\n\n        return result;\n    }\n\n    /**\n     *  intersectCircleCircle\n     *\n     *  @param {module:kld-intersections.Point2D} c1\n     *  @param {number} r1\n     *  @param {module:kld-intersections.Point2D} c2\n     *  @param {number} r2\n     *  @returns {module:kld-intersections.Intersection}\n     */\n    static intersectCircleCircle(c1, r1, c2, r2) {\n        let result;\n\n        // Determine minimum and maximum radii where circles can intersect\n        const r_max = r1 + r2;\n        const r_min = Math.abs(r1 - r2);\n\n        // Determine actual distance between circle circles\n        const c_dist = c1.distanceFrom(c2);\n\n        if (c_dist > r_max) {\n            result = new Intersection(\"Outside\");\n        }\n        else if (c_dist < r_min) {\n            result = new Intersection(\"Inside\");\n        }\n        else {\n            result = new Intersection(\"Intersection\");\n\n            const a = (r1 * r1 - r2 * r2 + c_dist * c_dist) / (2 * c_dist);\n            const h = Math.sqrt(r1 * r1 - a * a);\n            const p = c1.lerp(c2, a / c_dist);\n            const b = h / c_dist;\n\n            result.points.push(\n                new Point2D(\n                    p.x - b * (c2.y - c1.y),\n                    p.y + b * (c2.x - c1.x)\n                )\n            );\n            result.points.push(\n                new Point2D(\n                    p.x + b * (c2.y - c1.y),\n                    p.y - b * (c2.x - c1.x)\n                )\n            );\n        }\n\n        return result;\n    }\n\n    /**\n     *  intersectCircleEllipse\n     *\n     *  @param {module:kld-intersections.Point2D} cc\n     *  @param {number} r\n     *  @param {module:kld-intersections.Point2D} ec\n     *  @param {number} rx\n     *  @param {number} ry\n     *  @returns {module:kld-intersections.Intersection}\n     */\n    static intersectCircleEllipse(cc, r, ec, rx, ry) {\n        return Intersection.intersectEllipseEllipse(cc, r, r, ec, rx, ry);\n    }\n\n    /**\n     *  intersectCircleLine\n     *\n     *  @param {module:kld-intersections.Point2D} c\n     *  @param {number} r\n     *  @param {module:kld-intersections.Point2D} a1\n     *  @param {module:kld-intersections.Point2D} a2\n     *  @returns {module:kld-intersections.Intersection}\n     */\n    static intersectCircleLine(c, r, a1, a2) {\n        let result;\n        const a = (a2.x - a1.x) * (a2.x - a1.x) +\n                 (a2.y - a1.y) * (a2.y - a1.y);\n        const b = 2 * ((a2.x - a1.x) * (a1.x - c.x) +\n                       (a2.y - a1.y) * (a1.y - c.y));\n        const cc = c.x * c.x + c.y * c.y + a1.x * a1.x + a1.y * a1.y -\n                 2 * (c.x * a1.x + c.y * a1.y) - r * r;\n        const deter = b * b - 4 * a * cc;\n\n        if (deter < 0) {\n            result = new Intersection(\"Outside\");\n        }\n        else if (deter === 0) {\n            result = new Intersection(\"Tangent\");\n            // NOTE: should calculate this point\n        }\n        else {\n            const e = Math.sqrt(deter);\n            const u1 = (-b + e) / (2 * a);\n            const u2 = (-b - e) / (2 * a);\n\n            if ((u1 < 0 || u1 > 1) && (u2 < 0 || u2 > 1)) {\n                if ((u1 < 0 && u2 < 0) || (u1 > 1 && u2 > 1)) {\n                    result = new Intersection(\"Outside\");\n                }\n                else {\n                    result = new Intersection(\"Inside\");\n                }\n            }\n            else {\n                result = new Intersection(\"Intersection\");\n\n                if (0 <= u1 && u1 <= 1) {\n                    result.points.push(a1.lerp(a2, u1));\n                }\n\n                if (0 <= u2 && u2 <= 1) {\n                    result.points.push(a1.lerp(a2, u2));\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     *  intersectCirclePolygon\n     *\n     *  @param {module:kld-intersections.Point2D} c\n     *  @param {number} r\n     *  @param {Array<module:kld-intersections.Point2D>} points\n     *  @returns {module:kld-intersections.Intersection}\n     */\n    static intersectCirclePolygon(c, r, points) {\n        return Intersection.intersectCirclePolyline(c, r, closePolygon(points));\n    }\n\n    /**\n     *  intersectCirclePolyline\n     *\n     *  @param {module:kld-intersections.Point2D} c\n     *  @param {number} r\n     *  @param {Array<module:kld-intersections.Point2D>} points\n     *  @returns {module:kld-intersections.Intersection}\n     */\n    static intersectCirclePolyline(c, r, points) {\n        const result = new Intersection(\"No Intersection\");\n        const {length: len} = points;\n        let inter;\n\n        for (let i = 0; i < len - 1; i++) {\n            const a1 = points[i];\n            const a2 = points[i + 1];\n\n            inter = Intersection.intersectCircleLine(c, r, a1, a2);\n            result.appendPoints(inter.points);\n        }\n\n        if (result.points.length > 0) {\n            result.status = \"Intersection\";\n        }\n        else {\n            result.status = inter.status;\n        }\n\n        return result;\n    }\n\n    /**\n     *  intersectCircleRectangle\n     *\n     *  @param {module:kld-intersections.Point2D} c\n     *  @param {number} r\n     *  @param {module:kld-intersections.Point2D} r1\n     *  @param {module:kld-intersections.Point2D} r2\n     *  @returns {module:kld-intersections.Intersection}\n     */\n    static intersectCircleRectangle(c, r, r1, r2) {\n        const min = r1.min(r2);\n        const max = r1.max(r2);\n        const topRight = new Point2D(max.x, min.y);\n        const bottomLeft = new Point2D(min.x, max.y);\n\n        const inter1 = Intersection.intersectCircleLine(c, r, min, topRight);\n        const inter2 = Intersection.intersectCircleLine(c, r, topRight, max);\n        const inter3 = Intersection.intersectCircleLine(c, r, max, bottomLeft);\n        const inter4 = Intersection.intersectCircleLine(c, r, bottomLeft, min);\n\n        const result = new Intersection(\"No Intersection\");\n\n        result.appendPoints(inter1.points);\n        result.appendPoints(inter2.points);\n        result.appendPoints(inter3.points);\n        result.appendPoints(inter4.points);\n\n        if (result.points.length > 0) {\n            result.status = \"Intersection\";\n        }\n        else {\n            result.status = inter1.status;\n        }\n\n        return result;\n    }\n\n    /**\n     *  intersectEllipseEllipse\n     *\n     *  This code is based on MgcIntr2DElpElp.cpp written by David Eberly.  His\n     *  code along with many other excellent examples are avaiable at his site:\n     *  http://www.magic-software.com\n     *\n     *  NOTE: Rotation will need to be added to this function\n     *\n     *  @param {module:kld-intersections.Point2D} c1\n     *  @param {number} rx1\n     *  @param {number} ry1\n     *  @param {module:kld-intersections.Point2D} c2\n     *  @param {number} rx2\n     *  @param {number} ry2\n     *  @returns {module:kld-intersections.Intersection}\n     */\n    static intersectEllipseEllipse(c1, rx1, ry1, c2, rx2, ry2) {\n        const a = [\n            ry1 * ry1, 0, rx1 * rx1, -2 * ry1 * ry1 * c1.x, -2 * rx1 * rx1 * c1.y,\n            ry1 * ry1 * c1.x * c1.x + rx1 * rx1 * c1.y * c1.y - rx1 * rx1 * ry1 * ry1\n        ];\n        const b = [\n            ry2 * ry2, 0, rx2 * rx2, -2 * ry2 * ry2 * c2.x, -2 * rx2 * rx2 * c2.y,\n            ry2 * ry2 * c2.x * c2.x + rx2 * rx2 * c2.y * c2.y - rx2 * rx2 * ry2 * ry2\n        ];\n\n        const yPoly = bezout(a, b);\n        const yRoots = yPoly.getRoots();\n        const epsilon = 1e-3;\n        const norm0 = (a[0] * a[0] + 2 * a[1] * a[1] + a[2] * a[2]) * epsilon;\n        const norm1 = (b[0] * b[0] + 2 * b[1] * b[1] + b[2] * b[2]) * epsilon;\n        const result = new Intersection(\"No Intersection\");\n\n        for (let y = 0; y < yRoots.length; y++) {\n            const xPoly = new Polynomial(\n                a[0],\n                a[3] + yRoots[y] * a[1],\n                a[5] + yRoots[y] * (a[4] + yRoots[y] * a[2])\n            );\n            const xRoots = xPoly.getRoots();\n\n            for (let x = 0; x < xRoots.length; x++) {\n                let tst =\n                    (a[0] * xRoots[x] + a[1] * yRoots[y] + a[3]) * xRoots[x] +\n                    (a[2] * yRoots[y] + a[4]) * yRoots[y] + a[5];\n                if (Math.abs(tst) < norm0) {\n                    tst =\n                        (b[0] * xRoots[x] + b[1] * yRoots[y] + b[3]) * xRoots[x] +\n                        (b[2] * yRoots[y] + b[4]) * yRoots[y] + b[5];\n                    if (Math.abs(tst) < norm1) {\n                        result.appendPoint(new Point2D(xRoots[x], yRoots[y]));\n                    }\n                }\n            }\n        }\n\n        if (result.points.length > 0) {\n            result.status = \"Intersection\";\n        }\n\n        return result;\n    }\n\n    /**\n     *  intersectEllipseLine\n     *\n     *  NOTE: Rotation will need to be added to this function\n     *\n     *  @param {module:kld-intersections.Point2D} c\n     *  @param {number} rx\n     *  @param {number} ry\n     *  @param {module:kld-intersections.Point2D} a1\n     *  @param {module:kld-intersections.Point2D} a2\n     *  @returns {module:kld-intersections.Intersection}\n     */\n    static intersectEllipseLine(c, rx, ry, a1, a2) {\n        let result;\n        const orign = new Vector2D(a1.x, a1.y);\n        const dir = Vector2D.fromPoints(a1, a2);\n        const center = new Vector2D(c.x, c.y);\n        const diff = orign.subtract(center);\n        const mDir = new Vector2D(dir.x / (rx * rx), dir.y / (ry * ry));\n        const mDiff = new Vector2D(diff.x / (rx * rx), diff.y / (ry * ry));\n\n        const a = dir.dot(mDir);\n        const b = dir.dot(mDiff);\n        c = diff.dot(mDiff) - 1.0;\n        const d = b * b - a * c;\n\n        if (d < 0) {\n            result = new Intersection(\"Outside\");\n        }\n        else if (d > 0) {\n            const root = Math.sqrt(d); // eslint-disable-line no-shadow\n            const t_a = (-b - root) / a;\n            const t_b = (-b + root) / a;\n\n            if ((t_a < 0 || 1 < t_a) && (t_b < 0 || 1 < t_b)) {\n                if ((t_a < 0 && t_b < 0) || (t_a > 1 && t_b > 1)) {\n                    result = new Intersection(\"Outside\");\n                }\n                else {\n                    result = new Intersection(\"Inside\");\n                }\n            }\n            else {\n                result = new Intersection(\"Intersection\");\n                if (0 <= t_a && t_a <= 1) {\n                    result.appendPoint(a1.lerp(a2, t_a));\n                }\n                if (0 <= t_b && t_b <= 1) {\n                    result.appendPoint(a1.lerp(a2, t_b));\n                }\n            }\n        }\n        else {\n            const t = -b / a;\n\n            if (0 <= t && t <= 1) {\n                result = new Intersection(\"Intersection\");\n                result.appendPoint(a1.lerp(a2, t));\n            }\n            else {\n                result = new Intersection(\"Outside\");\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     *  intersectEllipsePolygon\n     *\n     *  @param {module:kld-intersections.Point2D} c\n     *  @param {number} rx\n     *  @param {number} ry\n     *  @param {Array<module:kld-intersections.Point2D>} points\n     *  @returns {module:kld-intersections.Intersection}\n     */\n    static intersectEllipsePolygon(c, rx, ry, points) {\n        return Intersection.intersectEllipsePolyline(c, rx, ry, closePolygon(points));\n    }\n\n    /**\n     *  intersectEllipsePolyline\n     *\n     *  @param {module:kld-intersections.Point2D} c\n     *  @param {number} rx\n     *  @param {number} ry\n     *  @param {Array<module:kld-intersections.Point2D>} points\n     *  @returns {module:kld-intersections.Intersection}\n     */\n    static intersectEllipsePolyline(c, rx, ry, points) {\n        const result = new Intersection(\"No Intersection\");\n        const {length: len} = points;\n\n        for (let i = 0; i < len - 1; i++) {\n            const b1 = points[i];\n            const b2 = points[i + 1];\n            const inter = Intersection.intersectEllipseLine(c, rx, ry, b1, b2);\n\n            result.appendPoints(inter.points);\n        }\n\n        if (result.points.length > 0) {\n            result.status = \"Intersection\";\n        }\n\n        return result;\n    }\n\n    /**\n     *  intersectEllipseRectangle\n     *\n     *  @param {module:kld-intersections.Point2D} c\n     *  @param {number} rx\n     *  @param {number} ry\n     *  @param {module:kld-intersections.Point2D} r1\n     *  @param {module:kld-intersections.Point2D} r2\n     *  @returns {module:kld-intersections.Intersection}\n     */\n    static intersectEllipseRectangle(c, rx, ry, r1, r2) {\n        const min = r1.min(r2);\n        const max = r1.max(r2);\n        const topRight = new Point2D(max.x, min.y);\n        const bottomLeft = new Point2D(min.x, max.y);\n\n        const inter1 = Intersection.intersectEllipseLine(c, rx, ry, min, topRight);\n        const inter2 = Intersection.intersectEllipseLine(c, rx, ry, topRight, max);\n        const inter3 = Intersection.intersectEllipseLine(c, rx, ry, max, bottomLeft);\n        const inter4 = Intersection.intersectEllipseLine(c, rx, ry, bottomLeft, min);\n\n        const result = new Intersection(\"No Intersection\");\n\n        result.appendPoints(inter1.points);\n        result.appendPoints(inter2.points);\n        result.appendPoints(inter3.points);\n        result.appendPoints(inter4.points);\n\n        if (result.points.length > 0) {\n            result.status = \"Intersection\";\n        }\n\n        return result;\n    }\n\n    /**\n     *  intersectLineLine\n     *\n     *  @param {module:kld-intersections.Point2D} a1\n     *  @param {module:kld-intersections.Point2D} a2\n     *  @param {module:kld-intersections.Point2D} b1\n     *  @param {module:kld-intersections.Point2D} b2\n     *  @returns {module:kld-intersections.Intersection}\n     */\n    static intersectLineLine(a1, a2, b1, b2) {\n        let result;\n\n        const ua_t = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x);\n        const ub_t = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x);\n        const u_b = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);\n\n        if (u_b !== 0) {\n            const ua = ua_t / u_b;\n            const ub = ub_t / u_b;\n\n            if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {\n                result = new Intersection(\"Intersection\");\n                result.points.push(\n                    new Point2D(\n                        a1.x + ua * (a2.x - a1.x),\n                        a1.y + ua * (a2.y - a1.y)\n                    )\n                );\n            }\n            else {\n                result = new Intersection(\"No Intersection\");\n            }\n        }\n        else if (ua_t === 0 || ub_t === 0) {\n            result = new Intersection(\"Coincident\");\n        }\n        else {\n            result = new Intersection(\"Parallel\");\n        }\n\n        return result;\n    }\n\n    /**\n     *  intersectLinePolygon\n     *\n     *  @param {module:kld-intersections.Point2D} a1\n     *  @param {module:kld-intersections.Point2D} a2\n     *  @param {Array<module:kld-intersections.Point2D>} points\n     *  @returns {module:kld-intersections.Intersection}\n     */\n    static intersectLinePolygon(a1, a2, points) {\n        return Intersection.intersectLinePolyline(a1, a2, closePolygon(points));\n    }\n\n    /**\n     *  intersectLinePolyline\n     *\n     *  @param {module:kld-intersections.Point2D} a1\n     *  @param {module:kld-intersections.Point2D} a2\n     *  @param {Array<module:kld-intersections.Point2D>} points\n     *  @returns {module:kld-intersections.Intersection}\n     */\n    static intersectLinePolyline(a1, a2, points) {\n        const result = new Intersection(\"No Intersection\");\n        const {length: len} = points;\n\n        for (let i = 0; i < len - 1; i++) {\n            const b1 = points[i];\n            const b2 = points[i + 1];\n            const inter = Intersection.intersectLineLine(a1, a2, b1, b2);\n\n            result.appendPoints(inter.points);\n        }\n\n        if (result.points.length > 0) {\n            result.status = \"Intersection\";\n        }\n\n        return result;\n    }\n\n    /**\n     *  intersectLineRectangle\n     *\n     *  @param {module:kld-intersections.Point2D} a1\n     *  @param {module:kld-intersections.Point2D} a2\n     *  @param {module:kld-intersections.Point2D} r1\n     *  @param {module:kld-intersections.Point2D} r2\n     *  @returns {module:kld-intersections.Intersection}\n     */\n    static intersectLineRectangle(a1, a2, r1, r2) {\n        const min = r1.min(r2);\n        const max = r1.max(r2);\n        const topRight = new Point2D(max.x, min.y);\n        const bottomLeft = new Point2D(min.x, max.y);\n\n        const inter1 = Intersection.intersectLineLine(min, topRight, a1, a2);\n        const inter2 = Intersection.intersectLineLine(topRight, max, a1, a2);\n        const inter3 = Intersection.intersectLineLine(max, bottomLeft, a1, a2);\n        const inter4 = Intersection.intersectLineLine(bottomLeft, min, a1, a2);\n\n        const result = new Intersection(\"No Intersection\");\n\n        result.appendPoints(inter1.points);\n        result.appendPoints(inter2.points);\n        result.appendPoints(inter3.points);\n        result.appendPoints(inter4.points);\n\n        if (result.points.length > 0) {\n            result.status = \"Intersection\";\n        }\n\n        return result;\n    }\n\n    /**\n     *  intersectPolygonPolygon\n     *\n     *  @param {Array<module:kld-intersections.Point2D>} points1\n     *  @param {Array<module:kld-intersections.Point2D>} points2\n     *  @returns {module:kld-intersections.Intersection}\n     */\n    static intersectPolygonPolygon(points1, points2) {\n        return Intersection.intersectPolylinePolyline(closePolygon(points1), closePolygon(points2));\n    }\n\n    /**\n     *  intersectPolygonPolyline\n     *\n     *  @param {Array<module:kld-intersections.Point2D>} points1\n     *  @param {Array<module:kld-intersections.Point2D>} points2\n     *  @returns {module:kld-intersections.Intersection}\n     */\n    static intersectPolygonPolyline(points1, points2) {\n        return Intersection.intersectPolylinePolyline(closePolygon(points1), points2);\n    }\n\n    /**\n     *  intersectPolygonRectangle\n     *\n     *  @param {Array<module:kld-intersections.Point2D>} points\n     *  @param {module:kld-intersections.Point2D} r1\n     *  @param {module:kld-intersections.Point2D} r2\n     *  @returns {module:kld-intersections.Intersection}\n     */\n    static intersectPolygonRectangle(points, r1, r2) {\n        return Intersection.intersectPolylineRectangle(closePolygon(points), r1, r2);\n    }\n\n    /**\n     *  intersectPolylinePolyline\n     *\n     *  @param {Array<module:kld-intersections.Point2D>} points1\n     *  @param {Array<module:kld-intersections.Point2D>} points2\n     *  @returns {module:kld-intersections.Intersection}\n     */\n    static intersectPolylinePolyline(points1, points2) {\n        const result = new Intersection(\"No Intersection\");\n        const {length: len} = points1;\n\n        for (let i = 0; i < len - 1; i++) {\n            const a1 = points1[i];\n            const a2 = points1[i + 1];\n            const inter = Intersection.intersectLinePolyline(a1, a2, points2);\n\n            result.appendPoints(inter.points);\n        }\n\n        if (result.points.length > 0) {\n            result.status = \"Intersection\";\n        }\n\n        return result;\n    }\n\n    /**\n     *  intersectPolylineRectangle\n     *\n     *  @param {Array<module:kld-intersections.Point2D>} points\n     *  @param {module:kld-intersections.Point2D} r1\n     *  @param {module:kld-intersections.Point2D} r2\n     *  @returns {module:kld-intersections.Intersection}\n     */\n    static intersectPolylineRectangle(points, r1, r2) {\n        const min = r1.min(r2);\n        const max = r1.max(r2);\n        const topRight = new Point2D(max.x, min.y);\n        const bottomLeft = new Point2D(min.x, max.y);\n\n        const inter1 = Intersection.intersectLinePolyline(min, topRight, points);\n        const inter2 = Intersection.intersectLinePolyline(topRight, max, points);\n        const inter3 = Intersection.intersectLinePolyline(max, bottomLeft, points);\n        const inter4 = Intersection.intersectLinePolyline(bottomLeft, min, points);\n\n        const result = new Intersection(\"No Intersection\");\n\n        result.appendPoints(inter1.points);\n        result.appendPoints(inter2.points);\n        result.appendPoints(inter3.points);\n        result.appendPoints(inter4.points);\n\n        if (result.points.length > 0) {\n            result.status = \"Intersection\";\n        }\n\n        return result;\n    }\n\n    /**\n     *  intersectRectangleRectangle\n     *\n     *  @param {module:kld-intersections.Point2D} a1\n     *  @param {module:kld-intersections.Point2D} a2\n     *  @param {module:kld-intersections.Point2D} b1\n     *  @param {module:kld-intersections.Point2D} b2\n     *  @returns {module:kld-intersections.Intersection}\n     */\n    static intersectRectangleRectangle(a1, a2, b1, b2) {\n        const min = a1.min(a2);\n        const max = a1.max(a2);\n        const topRight = new Point2D(max.x, min.y);\n        const bottomLeft = new Point2D(min.x, max.y);\n\n        const inter1 = Intersection.intersectLineRectangle(min, topRight, b1, b2);\n        const inter2 = Intersection.intersectLineRectangle(topRight, max, b1, b2);\n        const inter3 = Intersection.intersectLineRectangle(max, bottomLeft, b1, b2);\n        const inter4 = Intersection.intersectLineRectangle(bottomLeft, min, b1, b2);\n\n        const result = new Intersection(\"No Intersection\");\n\n        result.appendPoints(inter1.points);\n        result.appendPoints(inter2.points);\n        result.appendPoints(inter3.points);\n        result.appendPoints(inter4.points);\n\n        if (result.points.length > 0) {\n            result.status = \"Intersection\";\n        }\n\n        return result;\n    }\n\n    /**\n     *  intersectRayRay\n     *\n     *  @param {module:kld-intersections.Point2D} a1\n     *  @param {module:kld-intersections.Point2D} a2\n     *  @param {module:kld-intersections.Point2D} b1\n     *  @param {module:kld-intersections.Point2D} b2\n     *  @returns {module:kld-intersections.Intersection}\n     */\n    static intersectRayRay(a1, a2, b1, b2) {\n        let result;\n\n        const ua_t = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x);\n        const ub_t = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x);\n        const u_b = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);\n\n        if (u_b !== 0) {\n            const ua = ua_t / u_b;\n\n            result = new Intersection(\"Intersection\");\n            result.points.push(\n                new Point2D(\n                    a1.x + ua * (a2.x - a1.x),\n                    a1.y + ua * (a2.y - a1.y)\n                )\n            );\n        }\n        else if (ua_t === 0 || ub_t === 0) {\n            result = new Intersection(\"Coincident\");\n        }\n        else {\n            result = new Intersection(\"Parallel\");\n        }\n\n        return result;\n    }\n\n    /**\n     *  appendPoint\n     *\n     *  @param {module:kld-intersections.Point2D} point\n     */\n    appendPoint(point) {\n        this.points.push(point);\n    }\n\n\n    /**\n     *  appendPoints\n     *\n     *  @param {Array<module:kld-intersections.Point2D>} points\n     */\n    appendPoints(points) {\n        this.points = this.points.concat(points);\n    }\n}\n\nexport default Intersection;\n","/**\n *  Shapes\n *\n *  @copyright 2017, Kevin Lindsey\n *  @module Shapes\n */\n\nimport {Point2D} from \"kld-affine\";\n\nimport IntersectionArgs from \"./IntersectionArgs.js\";\n\n/**\n * @namespace\n */\nconst Shapes = {};\n\n/**\n *  quadraticBezier\n *\n *  @param {number} p1x\n *  @param {number} p1y\n *  @param {number} p2x\n *  @param {number} p2y\n *  @param {number} p3x\n *  @param {number} p3y\n *  @returns {module:kld-intersections.IntersectionArgs}\n */\nShapes.quadraticBezier = function(p1x, p1y, p2x, p2y, p3x, p3y) {\n    return new IntersectionArgs(\"Bezier2\", [\n        new Point2D(p1x, p1y),\n        new Point2D(p2x, p2y),\n        new Point2D(p3x, p3y)\n    ]);\n};\n\n/**\n *  cubicBezier\n *\n *  @param {number} p1x\n *  @param {number} p1y\n *  @param {number} p2x\n *  @param {number} p2y\n *  @param {number} p3x\n *  @param {number} p3y\n *  @param {number} p4x\n *  @param {number} p4y\n *  @returns {module:kld-intersections.IntersectionArgs}\n */\nShapes.cubicBezier = function(p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {\n    return new IntersectionArgs(\"Bezier3\", [\n        new Point2D(p1x, p1y),\n        new Point2D(p2x, p2y),\n        new Point2D(p3x, p3y),\n        new Point2D(p4x, p4y)\n    ]);\n};\n\n/**\n *  circle\n *\n *  @param {number} centerX\n *  @param {number} centerY\n *  @param {number} radius\n *  @returns {module:kld-intersections.IntersectionArgs}\n */\nShapes.circle = function(centerX, centerY, radius) {\n    return new IntersectionArgs(\"Circle\", [\n        new Point2D(centerX, centerY),\n        radius\n    ]);\n};\n\n/**\n *  ellipse\n *\n *  @param {number} centerX\n *  @param {number} centerY\n *  @param {number} radiusX\n *  @param {number} radiusY\n *  @returns {module:kld-intersections.IntersectionArgs}\n */\nShapes.ellipse = function(centerX, centerY, radiusX, radiusY) {\n    return new IntersectionArgs(\"Ellipse\", [\n        new Point2D(centerX, centerY),\n        radiusX,\n        radiusY\n    ]);\n};\n\n/**\n * arc\n *\n * @param {number} centerX\n * @param {number} centerY\n * @param {number} radiusX\n * @param {number} radiusY\n * @param {number} startRadians\n * @param {number} endRadians\n * @returns {module:kld-intersections.IntersectionArgs}\n */\nShapes.arc = function(centerX, centerY, radiusX, radiusY, startRadians, endRadians) {\n    return new IntersectionArgs(\"Arc\", [\n        new Point2D(centerX, centerY),\n        radiusX,\n        radiusY,\n        startRadians,\n        endRadians\n    ]);\n};\n\n/**\n *  line\n *\n *  @param {number} p1x\n *  @param {number} p1y\n *  @param {number} p2x\n *  @param {number} p2y\n *  @returns {module:kld-intersections.IntersectionArgs}\n */\nShapes.line = function(p1x, p1y, p2x, p2y) {\n    return new IntersectionArgs(\"Line\", [\n        new Point2D(p1x, p1y),\n        new Point2D(p2x, p2y)\n    ]);\n};\n\n/**\n *  path\n *\n *  @param {Array<module:kld-intersections.Shapes>} segments\n *  @returns {module:kld-intersections.IntersectionArgs}\n */\nShapes.path = function(segments) {\n    return new IntersectionArgs(\"Path\", segments);\n};\n\n/**\n *  polygon\n *\n *  @param {Array<number>} coords\n *  @returns {module:kld-intersections.IntersectionArgs}\n */\nShapes.polygon = function(coords) {\n    const points = [];\n\n    for (let i = 0; i < coords.length; i += 2) {\n        points.push(new Point2D(coords[i], coords[i + 1]));\n    }\n\n    return new IntersectionArgs(\"Polygon\", [points]);\n};\n\n/**\n *  polyline\n *\n *  @param {Array<number>} coords\n *  @returns {module:kld-intersections.IntersectionArgs}\n */\nShapes.polyline = function(coords) {\n    const points = [];\n\n    for (let i = 0; i < coords.length; i += 2) {\n        points.push(new Point2D(coords[i], coords[i + 1]));\n    }\n\n    return new IntersectionArgs(\"Polyline\", [points]);\n};\n\n/**\n *  rectangle\n *\n *  @param {number} x\n *  @param {number} y\n *  @param {number} width\n *  @param {number} height\n *  @returns {module:kld-intersections.IntersectionArgs}\n */\nShapes.rectangle = function(x, y, width, height) {\n    return new IntersectionArgs(\"Rectangle\", [\n        new Point2D(x, y),\n        new Point2D(x + width, y + height)\n    ]);\n};\n\nexport default Shapes;\n","/**\n *  AffineShapes\n *\n *  @copyright 2017, Kevin Lindsey\n *  @module AffineShapes\n */\n\nimport IntersectionArgs from \"./IntersectionArgs.js\";\n\n/**\n * @namespace\n */\nconst AffineShapes = {};\n\n/**\n *  quadraticBezier\n *  @param {module:kld-intersections.Point2D} p1\n *  @param {module:kld-intersections.Point2D} p2\n *  @param {module:kld-intersections.Point2D} p3\n *  @returns {module:kld-intersections.IntersectionArgs}\n */\nAffineShapes.quadraticBezier = function(p1, p2, p3) {\n    return new IntersectionArgs(\"Bezier2\", [p1, p2, p3]);\n};\n\n/**\n *  cubicBezier\n *\n *  @param {module:kld-intersections.Point2D} p1\n *  @param {module:kld-intersections.Point2D} p2\n *  @param {module:kld-intersections.Point2D} p3\n *  @param {module:kld-intersections.Point2D} p4\n *  @returns {module:kld-intersections.IntersectionArgs}\n */\nAffineShapes.cubicBezier = function(p1, p2, p3, p4) {\n    return new IntersectionArgs(\"Bezier3\", [p1, p2, p3, p4]);\n};\n\n/**\n *  circle\n *\n *  @param {module:kld-intersections.Point2D} center\n *  @param {number} radius\n *  @returns {module:kld-intersections.IntersectionArgs}\n */\nAffineShapes.circle = function(center, radius) {\n    return new IntersectionArgs(\"Circle\", [center, radius]);\n};\n\n/**\n *  ellipse\n *\n *  @param {module:kld-intersections.Point2D} center\n *  @param {number} radiusX\n *  @param {number} radiusY\n *  @returns {module:kld-intersections.IntersectionArgs}\n */\nAffineShapes.ellipse = function(center, radiusX, radiusY) {\n    return new IntersectionArgs(\"Ellipse\", [center, radiusX, radiusY]);\n};\n\n/**\n * arc\n *\n * @param {module:kld-intersections.Point2D} center\n * @param {number} radiusX\n * @param {number} radiusY\n * @param {number} startRadians\n * @param {number} endRadians\n * @returns {module:kld-intersections.IntersectionArgs}\n */\nAffineShapes.arc = function(center, radiusX, radiusY, startRadians, endRadians) {\n    return new IntersectionArgs(\"Arc\", [center, radiusX, radiusY, startRadians, endRadians]);\n};\n\n/**\n *  line\n *\n *  @param {module:kld-intersections.Point2D} p1\n *  @param {module:kld-intersections.Point2D} p2\n *  @returns {module:kld-intersections.IntersectionArgs}\n */\nAffineShapes.line = function(p1, p2) {\n    return new IntersectionArgs(\"Line\", [p1, p2]);\n};\n\n/**\n *  path\n *\n *  @param {Array<module:kld-intersections.AffineShapes>} segments\n *  @returns {module:kld-intersections.IntersectionArgs}\n */\nAffineShapes.path = function(segments) {\n    return new IntersectionArgs(\"Path\", [segments]);\n};\n\n/**\n *  polygon\n *\n *  @param {Array<module:kld-intersections.Point2D>} points\n *  @returns {module:kld-intersections.IntersectionArgs}\n */\nAffineShapes.polygon = function(points) {\n    return new IntersectionArgs(\"Polygon\", [points]);\n};\n\n/**\n *  polyline\n *\n *  @param {Array<module:kld-intersections.Point2D>} points\n *  @returns {module:kld-intersections.IntersectionArgs}\n */\nAffineShapes.polyline = function(points) {\n    return new IntersectionArgs(\"Polyline\", [points]);\n};\n\n/**\n *  rectangle\n *\n *  @param {module:kld-intersections.Point2D} topLeft\n *  @param {module:kld-intersections.Vector2D} size\n *  @returns {module:kld-intersections.IntersectionArgs}\n */\nAffineShapes.rectangle = function(topLeft, size) {\n    return new IntersectionArgs(\"Rectangle\", [topLeft, topLeft.add(size)]);\n};\n\nexport default AffineShapes;\n","/**\n *\n *  IntersectionQuery.js\n *\n *  @copyright 2017 Kevin Lindsey\n * @module IntersectionQuery\n */\n\nimport {Vector2D} from \"kld-affine\";\n\n/**\n * @namespace\n */\nconst IntersectionQuery = {};\n\n\n/**\n *  pointInCircle\n *\n *  @param {module:kld-intersections.Point2D} point\n *  @param {module:kld-intersections.Point2D} center\n *  @param {number} radius\n *  @returns {boolean}\n */\nIntersectionQuery.pointInCircle = function(point, center, radius) {\n    const v = Vector2D.fromPoints(center, point);\n\n    return v.length() <= radius;\n};\n\n\n/**\n *  pointInEllipse\n *\n *  @param {module:kld-intersections.Point2D} point\n *  @param {module:kld-intersections.Point2D} center\n *  @param {number} radiusX\n *  @param {number} radiusY\n *  @returns {boolean}\n */\nIntersectionQuery.pointInEllipse = function(point, center, radiusX, radiusY) {\n    const len = point.subtract(center);\n\n    return (len.x * len.x) / (radiusX * radiusX) + (len.y * len.y) / (radiusY * radiusY) <= 1;\n};\n\n\n/**\n *  pointInPolyline\n *\n *  @param {module:kld-intersections.Point2D} point\n *  @param {Array<module:kld-intersections.Point2D>} points\n */\nIntersectionQuery.pointInPolyline = function(point, points) {\n    const {length: len} = points;\n    let counter = 0;\n    let xInter;\n\n    let p1 = points[0];\n\n    for (let i = 1; i <= len; i++) {\n        const p2 = points[i % len];\n        const minY = Math.min(p1.y, p2.y);\n        const maxY = Math.max(p1.y, p2.y);\n        const maxX = Math.max(p1.x, p2.x);\n\n        if (p1.y !== p2.y && minY < point.y && point.y <= maxY && point.x <= maxX) {\n            xInter = (point.y - p1.y) * (p2.x - p1.x) / (p2.y - p1.y) + p1.x;\n\n            if (p1.x === p2.x || point.x <= xInter) {\n                counter++;\n            }\n        }\n\n        p1 = p2;\n    }\n\n    return (counter % 2 === 1);\n};\n\n\n/**\n *  pointInPolyline\n *\n *  @param {module:kld-intersections.Point2D} point\n *  @param {Array<module:kld-intersections.Point2D>} points\n */\nIntersectionQuery.pointInPolygon = IntersectionQuery.pointInPolyline;\n\n\n/**\n *  pointInRectangle\n *\n *  @param {module:kld-intersections.Point2D} point\n *  @param {module:kld-intersections.Point2D} topLeft\n *  @param {module:kld-intersections.Point2D} bottomRight\n *  @returns {boolean}\n */\nIntersectionQuery.pointInRectangle = function(point, topLeft, bottomRight) {\n    return (\n        topLeft.x <= point.x && point.x < bottomRight.x &&\n        topLeft.y <= point.y && point.y < bottomRight.y\n    );\n};\n\n\nexport default IntersectionQuery;\n"],"names":["Point2D","x","y","undefined","this","constructor","that","scalar","precision","Math","abs","t","omt","dx","dy","sqrt","min","max","matrix","a","c","e","b","d","f","Vector2D","divide","length","cos","dot","radians","acos","cross","subtract","project","percent","multiply","p1","p2","Matrix2D","isIdentity","det1","Error","idet","det2","det3","tx","ty","scale","center","scaleX","scaleY","s","sin","cx","cy","vector","unit","tan","E","F","G","H","Q","R","a1","atan2","a2","theta","phi","translation","rotation","nonUniformScaling","rotation0","join","sign","NaN","IDENTITY","Polynomial","coefs","i","arguments","push","_variable","_s","poly","slice","isNaN","result","d1","getDegree","d2","dmax","v1","v2","j","TOLERANCE","pop","minValue","eval","maxValue","tmp1","log","tmp2","LN10","ACCURACY","iters","ceil","LN2","value","signs","round","signString","n","range","iter","delta","sum","st","os","ost","Array","MAX","h","trapezoid","interpolate","derivative","simplify","getLinearRoot","getQuadraticRoots","getCubicRoots","getQuarticRoots","roots","bisection","droots","getDerivative","getRootsInInterval","results","c3","c2","c1","offset","discrim","halfB","ZEROepsilon","zeroErrorEstimate","root","tmp","pow","distance","angle","sqrt3","divide_scalar","poly_d","derrt","getRoots","sort","dery","nr","rb","bounds","maxabsX","minX","maxX","guesses","minmax","df","newton_secant_bisection","concat","an","reduce","m","v","nm","map","coefSelectionFunc","find2Max","acc","bi","nearmax","max_nearmax_pos","negX","posX","reverse","res","bounds_UpperReal_Fujiwara","urb","bounds_LowerReal_Fujiwara","err","pv","cv","prev","curr","undersqrt","accum","ai","prev_a","pos","neg","maxRealPos","maxRealNeg","minComplex","xs","ys","ns","diff","dift","ho","hp","w","den","x0","max_iterations","dfx","x_correction","x_new","y_atmin","y_atmax","prev_dfx","prev_x_ef_correction","min_correction_factor","isBounded","isEnoughCorrection","IntersectionArgs","name","args","init","TWO_PI","PI","UNIT_X","isNullish","o","normalizeAngle","normal","restrictPointsToArc","intersections","radiusX","radiusY","startRadians","endRadians","points","Intersection","startNormal","endNormal","p","angleBetween","fromPoints","appendPoint","status","closePolygon","copy","point","shape1","shape2","intersectPathShape","intersectArcShape","method","apply","path","shape","segment","inter","intersect","appendPoints","arc","ellipse","a3","b1","b2","b3","c12","add","c11","c10","c22","c21","c20","g","xp","xRoots","yp","yRoots","checkRoots","xRoot","k","b4","c23","c10x2","c10y2","c11x2","c11y2","c12x2","c12y2","c20x2","c20y2","c21x2","c21y2","c22x2","c22y2","c23x2","c23y2","p3","r","intersectBezier2Ellipse","ec","rx","ry","c0","rxrx","ryry","cl","p4","lerp","p5","p6","intersectBezier2Polyline","len","intersectBezier2Line","r1","r2","topRight","bottomLeft","inter1","inter2","inter3","inter4","a4","c13","e0","e1","e2","e3","f0","f1","f2","f3","g0","g1","g2","g3","h0","h1","h2","h3","i0","i1","i2","i3","intersectBezier3Ellipse","p7","p8","p9","p10","intersectBezier3Polyline","intersectBezier3Line","r_max","r_min","c_dist","distanceFrom","cc","intersectEllipseEllipse","deter","u1","u2","intersectCirclePolyline","intersectCircleLine","rx1","ry1","rx2","ry2","AB","AC","AD","AE","AF","BC","BE","BF","CD","DE","DF","BFpDE","BEmCD","norm0","norm1","tst","orign","dir","mDir","mDiff","t_a","t_b","intersectEllipsePolyline","intersectEllipseLine","ua_t","ub_t","u_b","ua","ub","intersectLinePolyline","intersectLineLine","points1","points2","intersectPolylinePolyline","intersectPolylineRectangle","intersectLineRectangle","Shapes","p1x","p1y","p2x","p2y","p3x","p3y","p4x","p4y","centerX","centerY","radius","segments","coords","width","height","AffineShapes","topLeft","size","IntersectionQuery","xInter","counter","minY","maxY","pointInPolygon","pointInPolyline","pointInRectangle","bottomRight"],"mappings":"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"}